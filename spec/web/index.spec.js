(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";function getInvalidAuthArgs(){function e(e){return"string"==typeof e}var t=[void 0,null,NaN,!0,42,"foo",["foo"],{foo:"foo"}],n=t.filter(function(t){return!e(t)});return n.filter(function(e){return!Array.isArray(e)}).map(function(e){return[e,"compliant text"]}).concat(n.map(function(e){return[[e],"compliant text"]})).concat(n.map(function(e){return["compliant handle",e]}))}var src_1=require("../src"),Promise=require("bluebird"),cache,getLiveKey,getProxyKey,openpgp,livekey,types;beforeEach(function(){cache=jasmine.createSpyObj("cache",["set","del","get","has"]),getLiveKey=jasmine.createSpy("getLiveKey"),getProxyKey=jasmine.createSpy("getProxyKey"),openpgp={crypto:{hash:jasmine.createSpyObj("hash",["sha256"])},key:jasmine.createSpyObj("key",["readArmored","generateKey"]),message:jasmine.createSpyObj("message",["fromText","readArmored"]),encrypt:jasmine.createSpy("encrypt"),decrypt:jasmine.createSpy("decrypt")},livekey={key:{},bp:{keys:[{id:"key-id"}],user:{ids:[]}},lock:jasmine.createSpy("lock"),unlock:jasmine.createSpy("unlock")}}),describe("default export: getOpgpService (config?: OpgpServiceFactoryConfig): OpgpService",function(){var e;beforeEach(function(){e=jasmine.objectContaining({getKeysFromArmor:jasmine.any(Function),encrypt:jasmine.any(Function),decrypt:jasmine.any(Function),sign:jasmine.any(Function),verify:jasmine.any(Function)})}),describe("when called without arguments",function(){var t;beforeEach(function(){t=src_1.default()}),it("returns an {OpgpService} instance",function(){expect(t).toEqual(e)})}),describe("when called with { cache?: CsrKeyCache<OpgpLiveKey>, getLiveKey?: LiveKeyFactory, getProxyKey?: ProxyKeyFactory, openpgp?: openpgp }",function(){var t;beforeEach(function(){openpgp.key.readArmored.and.returnValue({keys:[livekey.key]}),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(){t=src_1.default({cache:cache,getLiveKey:getLiveKey,getProxyKey:getProxyKey,openpgp:openpgp}),t.getKeysFromArmor("key-armor")}),it("returns an {OpgpService} instance based on the given dependencies ",function(){expect(t).toEqual(e),expect(openpgp.key.readArmored).toHaveBeenCalledWith("key-armor"),expect(getLiveKey).toHaveBeenCalledWith(livekey.key),expect(cache.set).toHaveBeenCalledWith(livekey),expect(getProxyKey).toHaveBeenCalledWith("key-handle",livekey.bp)})})}),describe("OpgpService",function(){var e;beforeEach(function(){e=src_1.default({cache:cache,getLiveKey:getLiveKey,openpgp:openpgp})}),describe("generateKey (passphrase: string, opts?: OpgpKeyOpts): Promise<OpgpProxyKey>",function(){it("delegates to the openpgp primitive",function(t){e.generateKey("secret passphrase").catch(function(){}).finally(function(){expect(openpgp.key.generateKey).toHaveBeenCalledWith(jasmine.objectContaining({passphrase:"secret passphrase",numBits:4096})),setTimeout(t)})}),describe("when the underlying openpgp primitive returns a newly generated key",function(){var t,n;beforeEach(function(){openpgp.key.generateKey.and.returnValue(Promise.resolve(livekey.key)),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(i){e.generateKey("secret passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("creates a new {OpgpLiveKey} instance from the new openpgp key",function(){expect(getLiveKey).toHaveBeenCalledWith(livekey.key)}),it("stores the new {OpgpLiveKey} instance in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(livekey)}),it("returns a Promise that resolves to the new {OpgpProxyKey} instance",function(){expect(n).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(n).toEqual(jasmine.objectContaining(livekey.bp)),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive throws an error",function(){var t,n;beforeEach(function(){openpgp.key.generateKey.and.throwError("boom")}),beforeEach(function(i){e.generateKey("secret passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to an {OpgpProxyKey} instance",function(){expect(t).toBeDefined(),expect(t.message).toBe("boom"),expect(n).not.toBeDefined()})}),describe("OgpgKeyOpts",function(){})}),describe("getKeysFromArmor (armor: string, opts?: OpgpKeyringOpts): Promise<OpgpProxyKey[]|OpgpProxyKey>",function(){it("delegates to the openpgp primitive",function(t){e.getKeysFromArmor("key-armor").catch(function(){}).finally(function(){expect(openpgp.key.readArmored).toHaveBeenCalledWith("key-armor"),setTimeout(t)})}),describe("when the underlying openpgp primitive returns a single key",function(){var t,n;beforeEach(function(){openpgp.key.readArmored.and.returnValue({keys:[livekey.key]}),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(i){e.getKeysFromArmor("key-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("creates a new {OpgpLiveKey} instance from the openpgp key",function(){expect(getLiveKey).toHaveBeenCalledWith(livekey.key)}),it("stores the new {OpgpLiveKey} instance in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(livekey)}),it("returns a Promise that resolves to a corresponding {OpgpProxyKey} instance",function(){expect(n).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(n).toEqual(jasmine.objectContaining(livekey.bp)),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive returns multiple keys",function(){var t,n;beforeEach(function(){openpgp.key.readArmored.and.returnValue({keys:[livekey.key,livekey.key]}),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(i){e.getKeysFromArmor("keys-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("creates new {OpgpLiveKey} instances from each openpgp key",function(){expect(getLiveKey.calls.allArgs()).toEqual([[livekey.key],[livekey.key]])}),it("stores the new {OpgpLiveKey} instances in the underlying cache",function(){expect(cache.set.calls.allArgs()).toEqual([[livekey],[livekey]])}),it("returns a Promise that resolves to corresponding {OpgpProxyKey} instances",function(){expect(n).toEqual(jasmine.any(Array)),expect(n.length).toBe(2),n.forEach(function(e){expect(e).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(e).toEqual(jasmine.objectContaining(livekey.bp))}),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive throws an error",function(){var t,n;beforeEach(function(){openpgp.key.readArmored.and.throwError("boom")}),beforeEach(function(i){e.getKeysFromArmor("key-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with the thrown error",function(){expect(t).toBeDefined(),expect(t.message).toBe("boom"),expect(n).not.toBeDefined()})})}),describe("unlock (keyRef: KeyRef, passphrase: string, opts?: UnlockOpts): Promise<OpgpProxyKey>",function(){describe("when given a valid handle string of a locked key and the correct passphrase",function(){var t,n,i;beforeEach(function(){livekey.bp.isLocked=!0,t={key:{},bp:{isLocked:!1,keys:[{id:"key-id"}],user:{ids:[]}}},cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.resolve(t)),cache.set.and.returnValue("unlocked-key-handle")}),beforeEach(function(t){e.unlock("valid-key-handle","secret passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("secret passphrase")}),it("stores the unlocked key in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to an {OpgpProxyKey} instance of the unlocked {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"unlocked-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when the referenced {OpgpLiveKey} instance is already unlocked",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.reject(new Error("key not locked")))}),beforeEach(function(i){e.unlock("unlocked-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("unlocked-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with a `key not locked` {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not locked")})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.unlock("stale-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given an incorrect passphrase",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.reject(new Error("fail to unlock key")))}),beforeEach(function(i){e.unlock("valid-key-handle","incorrect passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("incorrect passphrase")}),it("returns a Promise that rejects with a `fail to unlock key` {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("fail to unlock key")})}),describe("when the {OpgpLiveKey#unlock} method rejects with an {Error}",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){e.unlock("valid-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("lock (keyRef: KeyRef, passphrase: string, opts?: UnlockOpts): Promise<OpgpProxyKey>",function(){describe("when given a valid handle string of an unlocked key and a passphrase string",function(){var t,n,i;beforeEach(function(){livekey.bp.isLocked=!1,t={key:{},bp:{isLocked:!0,keys:[{id:"key-id"}],user:{ids:[]}}},cache.get.and.returnValue(livekey),livekey.lock.and.returnValue(Promise.resolve(t)),cache.set.and.returnValue("locked-key-handle")}),beforeEach(function(t){e.lock("unlocked-key-handle","secret passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("unlocked-key-handle")}),it("invalidates the original {OpgpLiveKey} from the cache",function(){expect(cache.del).toHaveBeenCalledWith("unlocked-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.lock).toHaveBeenCalledWith("secret passphrase")}),it("stores the unlocked key in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to an {OpgpProxyKey} instance of the locked {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"locked-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when the referenced {OpgpLiveKey} instance is already locked",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey)}),beforeEach(function(i){e.lock("locked-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("locked-key-handle")}),it("does not invalidate the original {OpgpLiveKey} from the cache",function(){expect(cache.del).not.toHaveBeenCalled()}),it("does notdelegate to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.lock).not.toHaveBeenCalled()}),it("returns a Promise that rejects with a `key not unlocked` {Error} from the {OpgpLiveKey#lock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not unlocked")})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.lock("stale-key-handle","secret passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when the {OpgpLiveKey#lock} method rejects with an {Error}",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey),livekey.lock.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){e.lock("valid-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("invalidates the original {OpgpLiveKey} from the cache",function(){expect(cache.del).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.lock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#lock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("encrypt (keyRefs: KeyRefMap, plain: string, opts?: EncryptOpts): Promise<string>",function(){describe("when given a valid plain text string, and valid handles of valid public cipher and private authentication keys",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.encrypt.and.returnValue({data:"cipher text"})}),beforeEach(function(i){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.encrypt(r,"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-auth-key-handle"],["valid-cipher-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.encrypt).toHaveBeenCalledWith(jasmine.objectContaining({data:"plain text",publicKeys:[livekey.key],privateKeys:[livekey.key]}))}),it("returns a Promise that resolves to an armor string of the given text string encrypted with the referenced cipher {OpgpLiveKey} instances and signed with the referenced authentication {OpgpLiveKey} instances ",function(){expect(n).toBe("cipher text"),expect(t).not.toBeDefined()})}),describe("when given a valid plain text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){var r={cipher:"stale-key-handle",auth:"stale-key-handle"};e.encrypt(r,"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.encrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given a valid plain text string, and a valid handle string of a locked private key",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey)}),beforeEach(function(i){var r={cipher:"cipher-key-handle",auth:"locked-auth-key-handle"};e.encrypt(r,"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("locked-auth-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.encrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `private key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("private key not unlocked")})}),describe("when the underlying openpgp primitive rejects with an {Error}",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.encrypt.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.encrypt(r,"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-auth-key-handle"],["valid-cipher-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.encrypt).toHaveBeenCalledWith(jasmine.objectContaining({data:"plain text",publicKeys:[livekey.key],privateKeys:[livekey.key]}))}),it("returns a Promise that rejects with the {Error} from the openpgp primitive",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("decrypt (keyRefs: KeyRefMap, cipher: string, opts?: DecryptOpts): Promise<string>",function(){var t;beforeEach(function(){t={}}),describe("when given a valid cipher text string, and valid handles of valid public authentication and a private cipher key",function(){var n,i;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),openpgp.decrypt.and.returnValue({data:"plain text"})}),beforeEach(function(t){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.decrypt(r,"cipher text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-cipher-key-handle"],["valid-auth-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("cipher text"),expect(openpgp.decrypt).toHaveBeenCalledWith(jasmine.objectContaining({message:t,publicKeys:[livekey.key],privateKey:livekey.key}))}),it("returns a Promise that resolves to an armor string of the given text string decrypted with the referenced cipher {OpgpLiveKey} instance and authenticated with the referenced authentication {OpgpLiveKey} instances ",function(){expect(i).toBe("plain text"),expect(n).not.toBeDefined()})}),describe("when given a valid plain text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){var r={cipher:"stale-key-handle",auth:"stale-key-handle"};e.decrypt(r,"cipher text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled(),expect(openpgp.decrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given a valid plain text string, and a valid handle string of a locked private key",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey)}),beforeEach(function(i){var r={cipher:"locked-cipher-key-handle",auth:"auth-key-handle"};e.decrypt(r,"cipher text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("locked-cipher-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled(),expect(openpgp.decrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `private key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("private key not unlocked")})}),describe("when the underlying openpgp primitive rejects with an {Error}",function(){var n,i;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),openpgp.decrypt.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(t){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.decrypt(r,"cipher text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-cipher-key-handle"],["valid-auth-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("cipher text"),expect(openpgp.decrypt).toHaveBeenCalledWith(jasmine.objectContaining({message:t,publicKeys:[livekey.key],privateKey:livekey.key}))}),it("returns a Promise that rejects with the {Error} from the openpgp primitive",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("boom")})})}),describe("sign (keyRefs: KeyRef[]|KeyRef, text: string, opts?: SignOpts): Promise<string>",function(){var t;beforeEach(function(){t=jasmine.createSpyObj("message",["sign","armor"])}),describe("when given a text string and a valid handle string that is not stale",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(livekey),openpgp.message.fromText.and.returnValue(t),t.sign.and.returnValue(t),t.armor.and.returnValue("signed-armor-text")}),beforeEach(function(t){e.sign("valid-key-handle","plain text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.fromText).toHaveBeenCalledWith("plain text"),expect(t.sign).toHaveBeenCalledWith([livekey.key]),expect(t.armor).toHaveBeenCalledWith()}),it("returns a Promise that resolves to an armor string of the given text string signed with the referenced {OpgpLiveKey} instance ",function(){expect(i).toBe("signed-armor-text"),expect(n).not.toBeDefined()})}),describe("when given a text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.sign("stale-key-handle","plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.fromText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given non-compliant arguments",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey)}),beforeEach(function(i){var r=getInvalidAuthArgs();Promise.any(r.map(function(t){return e.sign.apply(e,t)})).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){cache.get.calls.allArgs().forEach(function(e){return expect(e).toEqual(["compliant handle"])})}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.fromText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` or an `invalid text: not a string` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Promise.AggregateError)),t.forEach(function(e){expect(e).toEqual(jasmine.any(Error)),expect(e.message).toEqual(jasmine.stringMatching(/invalid key reference: not a string or stale|invalid text: not a string/))})})})}),describe("verify (keyRefs: KeyRef[]|KeyRef, armor: string, opts?: VerifyOpts): Promise<string>",function(){var t;beforeEach(function(){t=jasmine.createSpyObj("message",["verify","getText"])}),describe("when given a signed armor text string and the valid handle string of the corresponding authentication key",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),t.verify.and.returnValue([{keyid:"keyid",valid:!0}]),t.getText.and.returnValue("plain-text")}),beforeEach(function(t){e.verify("valid-auth-key-handle","signed armor text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-auth-key-handle")}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("signed armor text"),expect(t.verify).toHaveBeenCalledWith([livekey.key]),expect(t.getText).toHaveBeenCalledWith()}),it("returns a Promise that resolves to the plain text string",function(){expect(i).toBe("plain-text"),expect(n).not.toBeDefined()})}),describe("when given a signed armor text string and a valid handle string of the wrong authentication key",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),t.verify.and.returnValue([{keyid:"verified-keyid",valid:!0},{keyid:"wrong-keyid",valid:!1},{keyid:"another-wrong-keyid",valid:!1}])}),beforeEach(function(t){e.verify(["correct-key-handle","wrong-key-handle","another-wrong-key-handle"],"signed armor text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get.calls.allArgs()).toEqual([["correct-key-handle"],["wrong-key-handle"],["another-wrong-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("signed armor text"),expect(t.verify).toHaveBeenCalledWith([livekey.key,livekey.key,livekey.key]),expect(t.getText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an {Error} containing a message with a trailing list of the key IDs that fail authentication",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("authentication failed: wrong-keyid,another-wrong-keyid")})}),describe("when given a signed armor text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.verify("stale-key-handle","signed armor text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given non-compliant arguments",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey)}),beforeEach(function(i){var r=getInvalidAuthArgs();Promise.any(r.map(function(t){return e.verify.apply(e,t)})).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){cache.get.calls.allArgs().forEach(function(e){return expect(e).toEqual(["compliant handle"])})}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` or an `invalid armor: not a string` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Promise.AggregateError)),t.forEach(function(e){expect(e).toEqual(jasmine.any(Error)),expect(e.message).toEqual(jasmine.stringMatching(/invalid key reference: not a string or stale|invalid armor: not a string/));
})})})})});
},{"../src":3,"bluebird":undefined}],2:[function(require,module,exports){
"use strict";var live_key_1=require("../src/live-key"),base64=require("base64-js"),getLiveKey,openpgp,key,subkeys,packets,msg,blueprint,cloneKey;beforeEach(function(){openpgp={crypto:{hash:jasmine.createSpyObj("hash",["sha256"])},key:jasmine.createSpyObj("key",["readArmored"]),message:jasmine.createSpyObj("message",["fromText","readArmored"])},key=jasmine.createSpyObj("key",["armor","getAllKeyPackets","isPublic","getUserIds","getSigningKeyPacket","getEncryptionKeyPacket","verifyPrimaryKey","getExpirationTime","encrypt","decrypt"]),packets=[0,1,2,3].map(function(e){return jasmine.createSpyObj("packet"+e,["getFingerprint","writeOld"])}),subkeys=[0,1,2].map(function(e){return jasmine.createSpyObj("subkey"+e,["isValidEncryptionKey","isValidSigningKey","verify","getExpirationTime"])}),msg=jasmine.createSpyObj("msg",["sign","verify"]),key.armor.and.returnValue("key-armor"),key.getAllKeyPackets.and.returnValue(packets),key.isPublic.and.returnValue(!1),key.getUserIds.and.returnValue(["user@test.io"]),key.getSigningKeyPacket.and.returnValue(packets[0]),key.getEncryptionKeyPacket.and.returnValue(packets[0]),key.verifyPrimaryKey.and.returnValue(6510),packets.forEach(function(e,t){e.getFingerprint.and.returnValue(t.toString()),e.writeOld.and.returnValue(["old"+t])}),subkeys.forEach(function(e,t){e.isValidEncryptionKey.and.returnValue(!0),e.isValidSigningKey.and.returnValue(!0),e.verify.and.returnValue(6511+t),e.getExpirationTime.and.returnValue(new Date(1984-t))}),key.primaryKey={isDecrypted:!1},key.subKeys=subkeys,cloneKey=function(e){var t=Object.assign({},e);return t.primaryKey={isDecrypted:e.primaryKey.isDecrypted},t.subKeys=e.subKeys.slice(),t},openpgp.crypto.hash.sha256.and.returnValue(base64.toByteArray("c2hhMjU2")),openpgp.key.readArmored.and.callFake(function(){return{keys:[cloneKey(key)]}}),openpgp.message.readArmored.and.returnValue(msg),openpgp.message.fromText.and.returnValue(msg),blueprint={isLocked:!0,isPublic:!1,keys:[0,1,2,3].map(function(e){return{isAuth:!0,isCiph:!0,expires:e?1985-e:1/0,fingerprint:e.toString(),hash:"c2hhMjU2",status:6510+e}}),user:{ids:["user@test.io"]}}}),beforeEach(function(){getLiveKey=live_key_1.default({openpgp:openpgp})}),describe("default export: getLiveKeyFactory (config: {openpgp:any}): LiveKeyFactory",function(){it("returns a {LiveKey} factory when given an instance of openpgp",function(){expect(getLiveKey).toEqual(jasmine.any(Function))})}),describe("LiveKeyFactory: getLiveKey (key: any, opts?: LiveKeyFactoryOpts): OpgpLiveKey",function(){var e;beforeEach(function(){e=getLiveKey(key)}),it("returns a {OpgpLiveKey} instance that wraps the given openpgp key",function(){expect(e).toEqual(jasmine.objectContaining({key:key,bp:jasmine.any(Object),armor:jasmine.any(Function),unlock:jasmine.any(Function),lock:jasmine.any(Function),sign:jasmine.any(Function),verify:jasmine.any(Function)}))})}),describe("OpgpLiveKey",function(){var e;beforeEach(function(){e=getLiveKey(key)}),describe("bp: OpgpKeyBlueprint",function(){var t;beforeEach(function(){t=e.bp}),it("is a blueprint of the openpgp wrapped in the {OpgpLiveKey} instance:\n{\n  isLocked: boolean,\n  isPublic: boolean,\n  keys: OpgpKeyId[],\n  user: { ids: string[] }\n}\nwhere each {OpgpKeyId} element in `keys` is a blueprint of the corresponding key component:\n{\n  isAuth: boolean,\n  isCiph: boolean,\n  expires: number,\n  fingerprint: string,\n  hash: string,\n  status: number\n}",function(){expect(t).toEqual(blueprint)})}),describe("armor (): Promise<string>",function(){describe("when the openpgp primitive succeeds",function(){var t,n;beforeEach(function(r){e.armor().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that resolves to an armored string representation of the wrapped openpgp key when the openpgp primitive succeeds",function(){expect(key.armor).toHaveBeenCalled(),expect(n).toBe("key-armor"),expect(t).not.toBeDefined()})}),describe("when the openpgp primitive fails",function(){var t,n;beforeEach(function(r){key.armor.and.throwError("boom"),e.armor().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with the error from the openpgp primitive when it fails",function(){expect(key.armor).toHaveBeenCalled(),expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("boom")})})}),describe("unlock (passphrase: string, opts?: LiveKeyUnlockOpts): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){t=cloneKey(key),t.primaryKey.isDecrypted=!0}),describe("when given the correct passphrase",function(){var n,r;beforeEach(function(i){openpgp.key.readArmored.and.callFake(function(){var e=cloneKey(t);return e.decrypt=jasmine.createSpy("decrypt").and.returnValue(!0),{keys:[e]}}),e.unlock("correct passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to a new, unlocked {OpgpLiveKey} instance",function(){expect(n).not.toBeDefined(),expect(r).not.toBe(e),expect(r.bp.isLocked).toBe(!1)}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0),expect(e.key.decrypt).not.toHaveBeenCalled()})}),describe("when given an incorrect passphrase",function(){var t,n;beforeEach(function(r){key.decrypt.and.returnValue(!1),e.unlock("incorrect passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with a `fail to unlock key` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("fail to unlock key")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0)})}),describe("when its {OpgpLiveKey} is already unlocked",function(){var n,r;beforeEach(function(i){e=getLiveKey(t),e.unlock("passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with a `key not locked` {Error}",function(){expect(r).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("key not locked")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(t),expect(e.key.primaryKey.isDecrypted).toBe(!0),expect(e.bp.isLocked).toBe(!1)})}),describe("when the openpgp primitive throws an exception",function(){var t,n;beforeEach(function(r){key.decrypt.and.throwError("boom"),e.unlock("passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with the corresponding error",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0)})})}),describe("lock (passphrase: string, opts?: LiveKeyUnlockOpts): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){t=cloneKey(key),t.primaryKey.isDecrypted=!0}),describe("when given a passphrase",function(){var n,r;beforeEach(function(i){t.encrypt=jasmine.createSpy("encrypt").and.callFake(function(){return t.primaryKey.isDecrypted=!1}),e=getLiveKey(t),e.lock("passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to a new, locked {OpgpLiveKey} instance",function(){expect(n).not.toBeDefined(),expect(r).not.toBe(e),expect(r.bp.isLocked).toBe(!0)}),it("invalidates its {OpgpLiveKey} instance",function(){expect(e.key).not.toBeDefined()})}),describe("when its {OpgpLiveKey} is already locked",function(){var t,n;beforeEach(function(r){e.lock("passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with a `key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not unlocked")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0)})}),describe("when the openpgp primitive throws an exception",function(){var n,r;beforeEach(function(i){key.encrypt.and.throwError("boom"),e=getLiveKey(t),e.lock("incorrect passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with the corresponding error",function(){expect(r).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("boom")}),it("invalidates its {OpgpLiveKey} instance",function(){expect(e.key).not.toBeDefined()})})})});

},{"../src/live-key":4,"base64-js":undefined}],3:[function(require,module,exports){
"use strict";function reject(e){return Promise.reject(new Error(e))}function getHandle(e){var t=utils_1.isString(e)?e:!!e&&e.handle;return utils_1.isString(t)&&t}function getOpenpgp(e){var t=isOpenpgp(e)?e:require("openpgp");return t}function isOpenpgp(e){return!!e&&["crypto","key","message"].every(function(t){return!!e[t]})}var live_key_1=require("./live-key"),proxy_key_1=require("./proxy-key"),utils_1=require("./utils"),csrkey_cache_1=require("csrkey-cache"),Promise=require("bluebird"),tslib_1=require("tslib"),OpgpServiceClass=function(){function e(e,t,r,n){this.cache=e,this.getLiveKey=t,this.getProxyKey=r,this.openpgp=n}return e.prototype.generateKey=function(e,t){var r=this;return utils_1.isString(e)?Promise.try(function(){var n={userIds:t&&[].concat(t.users),passphrase:e,numBits:t&&t.size||4096,unlocked:t&&!!t.unlocked};return r.openpgp.key.generateKey(n).then(function(e){return r.cacheAndProxyKey(r.getLiveKey(e))})}):reject("invalid passphrase: not a string")},e.prototype.getKeysFromArmor=function(e,t){var r=this;return utils_1.isString(e)?Promise.try(function(){var t=r.openpgp.key.readArmored(e).keys.map(function(e){return r.cacheAndProxyKey(r.getLiveKey(e))});return t.length>1?t:t[0]}):reject("invalid armor: not a string")},e.prototype.unlock=function(e,t,r){var n=this;return utils_1.isString(t)?Promise.try(function(){return n.getCachedLiveKey(e).unlock(t)}).then(function(e){return n.cacheAndProxyKey(e)}):reject("invalid passphrase: not a string")},e.prototype.lock=function(e,t,r){var n=this;return utils_1.isString(t)?Promise.try(function(){var r=n.getCachedLiveKey(e);if(r.bp.isLocked)return reject("key not unlocked");var i=getHandle(e);return n.cache.del(i),r.lock(t)}).then(function(e){return n.cacheAndProxyKey(e)}):reject("invalid passphrase: not a string")},e.prototype.encrypt=function(e,t,r){var n=this;return utils_1.isString(t)?Promise.try(function(){return n.openpgp.encrypt({privateKeys:n.getCachedPrivateOpenpgpKeys(e.auth),publicKeys:n.getCachedOpenpgpKeys(e.cipher),data:t})}).get("data"):reject("invalid plain text: not a string")},e.prototype.decrypt=function(e,t,r){var n=this;return utils_1.isString(t)?Promise.try(function(){return n.openpgp.decrypt({privateKey:n.getCachedPrivateOpenpgpKeys(e.cipher)[0],publicKeys:n.getCachedOpenpgpKeys(e.auth),message:n.openpgp.message.readArmored(t)})}).get("data"):reject("invalid cipher: not a string")},e.prototype.sign=function(e,t,r){var n=this;return Promise.try(function(){var r=n.getCachedOpenpgpKeys(e);if(!utils_1.isString(t))return reject("invalid text: not a string");var i=n.openpgp.message.fromText(t);return i.sign(r).armor()})},e.prototype.verify=function(e,t,r){var n=this;return Promise.try(function(){var r=n.getCachedOpenpgpKeys(e);if(!utils_1.isString(t))return reject("invalid armor: not a string");var i=n.openpgp.message.readArmored(t),o=i.verify(r).filter(function(e){return!e.valid}).map(function(e){return e.keyid}).join();return o?reject("authentication failed: "+o):i.getText()})},e.prototype.getCachedLiveKey=function(e){var t=getHandle(e),r=t&&this.cache.get(t);if(!r)throw new Error("invalid key reference: not a string or stale");return r},e.prototype.getCachedLiveKeys=function(e){var t=this,r=[].concat(e);if(!r.length)throw new Error("no key references");return r.map(function(e){return t.getCachedLiveKey(e)})},e.prototype.getCachedOpenpgpKeys=function(e){return this.getCachedLiveKeys(e).map(function(e){return e.key})},e.prototype.getCachedPrivateOpenpgpKeys=function(e){var t=this.getCachedLiveKeys(e);if(t.some(function(e){return e.bp.isLocked}))throw new Error("private key not unlocked");return t.map(function(e){return e.key})},e.prototype.cacheAndProxyKey=function(e){var t=this.cache.set(e);if(!t)throw new Error("fail to cache key");return this.getProxyKey(t,e.bp)},e}();OpgpServiceClass.getInstance=function(e){var t=tslib_1.__assign({},e),r=t.cache||csrkey_cache_1.default(),n=getOpenpgp(t.openpgp),i=t.getLiveKey||live_key_1.default({openpgp:n});return new OpgpServiceClass(r,i,t.getProxyKey||proxy_key_1.default,n)};var getOpgpService=OpgpServiceClass.getInstance;Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=getOpgpService;

},{"./live-key":4,"./proxy-key":5,"./utils":6,"bluebird":undefined,"csrkey-cache":undefined,"openpgp":undefined,"tslib":undefined}],4:[function(require,module,exports){
"use strict";function isLocked(e){return!e.primaryKey.isDecrypted}function getExpiry(e){var t=e.getExpirationTime();return t?t.getTime():1/0}var base64=require("base64-js"),Promise=require("bluebird"),tslib_1=require("tslib"),LiveKeyClass=function(){function e(e,t,r){this.utils=e,this.key=t,this.bp=r}return e.prototype.armor=function(){var e=this;return Promise.try(function(){return e.key.armor()})},e.prototype.unlock=function(t,r){var i=this;return this.bp.isLocked?Promise.try(function(){var r=i.utils.cloneKey(i.key),n=r.decrypt(t);return n?e.getInstance(i.utils,r):Promise.reject(new Error("fail to unlock key"))}):Promise.reject(new Error("key not locked"))},e.prototype.lock=function(t,r){var i=this;return this.bp.isLocked?Promise.reject(new Error("key not unlocked")):Promise.try(function(){return i.key.encrypt(t),e.getInstance(i.utils,i.key)}).finally(function(){return delete i.key})},e.prototype.sign=function(e,t){var r=this;return Promise.try(function(){return r.utils.openpgp.message.fromText(e).sign([r.key]).armor()})},e.prototype.verify=function(e,t){var r=this;return Promise.try(function(){var t=r.utils.openpgp.message.readArmored(e),i=t.verify([r.key]);return!!i.length&&i[0].valid&&t.getText()})},e.getInstance=function(t,r,i){var n=t.getKeyBlueprint(r);return new e(t,r,n)},e}();LiveKeyClass.getFactory=function(e){var t=new OpenpgpKeyUtils(e.openpgp);return LiveKeyClass.getInstance.bind(LiveKeyClass,t)};var OpenpgpKeyUtils=function(){function e(e){this.openpgp=e}return e.prototype.getKeyBlueprint=function(e){var t=this,r=e.getAllKeyPackets(),i=this.getOpgpKeyId(e,r[0]),n=r.slice(1).map(function(r,i){return t.getOpgpKeyId(e,r,i)});return{isLocked:isLocked(e),isPublic:e.isPublic(),keys:[i].concat(n),user:{ids:e.getUserIds()}}},e.prototype.getHashes=function(e){return{hash:this.getFingerprintHash(e),fingerprint:e.getFingerprint()}},e.prototype.getPrimaryKeyType=function(e){var t=this.cloneKey(e);return t.subKeys=null,{isAuth:!!t.getSigningKeyPacket(),isCiph:!!t.getEncryptionKeyPacket()}},e.prototype.getFingerprintHash=function(e,t){var r=e.writeOld(),i=this.openpgp.crypto.hash[t&&t.hash||"sha256"](r);return base64.fromByteArray(i)},e.prototype.cloneKey=function(e){return this.openpgp.key.readArmored(e.armor()).keys[0]},e.prototype.getOpgpKeyId=function(e,t,r){return"undefined"==typeof r?this.getPrimaryOpgpKeyId(e,t):this.getSubkeyOpgpKeyId(e,t,r)},e.prototype.getPrimaryOpgpKeyId=function(e,t){return tslib_1.__assign(this.getHashes(t),this.getPrimaryKeyType(e),{status:e.verifyPrimaryKey(),expires:getExpiry(e)})},e.prototype.getSubkeyOpgpKeyId=function(e,t,r){var i=e.subKeys[r];return tslib_1.__assign(this.getHashes(t),{isCiph:i.isValidEncryptionKey(e.primaryKey),isAuth:i.isValidSigningKey(e.primaryKey),status:i.verify(e.primaryKey),expires:getExpiry(i)})},e}(),getLiveKeyFactory=LiveKeyClass.getFactory;Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=getLiveKeyFactory;
},{"base64-js":undefined,"bluebird":undefined,"tslib":undefined}],5:[function(require,module,exports){
"use strict";var tslib_1=require("tslib"),getProxyKey=function(e,s){var r=tslib_1.__assign({handle:e},s);return r.keys=s.keys.map(function(e){return tslib_1.__assign({},e)}),r.user={ids:s.user.ids.slice()},r};Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=getProxyKey;

},{"tslib":undefined}],6:[function(require,module,exports){
"use strict";function isString(t){return"string"==typeof(t&&t.valueOf())}exports.isString=isString;
},{}]},{},[1,2]);
