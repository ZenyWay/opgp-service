(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";function getInvalidAuthArgs(){function e(e){return"string"==typeof e}var t=[void 0,null,NaN,!0,42,"foo",["foo"],{foo:"foo"}],n=t.filter(function(t){return!e(t)});return n.filter(function(e){return!Array.isArray(e)}).map(function(e){return[e,"compliant text"]}).concat(n.map(function(e){return[[e],"compliant text"]})).concat(n.map(function(e){return["compliant handle",e]}))}Object.defineProperty(exports,"__esModule",{value:!0});var src_1=require("../src"),Promise=require("bluebird"),cache,getLiveKey,getProxyKey,openpgp,livekey,types;beforeEach(function(){cache=jasmine.createSpyObj("cache",["set","del","get","has"]),getLiveKey=jasmine.createSpy("getLiveKey"),getProxyKey=jasmine.createSpy("getProxyKey"),openpgp={config:{},crypto:{hash:jasmine.createSpyObj("hash",["sha256"])},key:jasmine.createSpyObj("key",["readArmored","generate"]),message:jasmine.createSpyObj("message",["fromText","readArmored"]),encrypt:jasmine.createSpy("encrypt"),decrypt:jasmine.createSpy("decrypt")},livekey={key:{},bp:{keys:[{id:"key-id"}],user:{ids:[]}},armor:jasmine.createSpy("armor"),toPublicKey:jasmine.createSpy("toPublicKey"),lock:jasmine.createSpy("lock"),unlock:jasmine.createSpy("unlock")}}),describe("default export: getOpgpService (config?: OpgpServiceFactoryConfig): OpgpService",function(){var e;beforeEach(function(){var t=["configure","generateKey","getPublicKey","getKeysFromArmor","getArmorFromKey","encrypt","decrypt","sign","verify"];e=jasmine.objectContaining(t.reduce(function(e,t){return e[t]=jasmine.any(Function),e},{}))}),describe("when called without arguments",function(){var t;beforeEach(function(){t=src_1.default()}),it("returns an {OpgpService} instance",function(){expect(t).toEqual(e)})}),describe("when called with { cache?: CsrKeyCache<OpgpLiveKey>, getLiveKey?: LiveKeyFactory, getProxyKey?: ProxyKeyFactory, openpgp?: openpgp }",function(){var t;beforeEach(function(){openpgp.key.readArmored.and.returnValue({keys:[livekey.key]}),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(e){t=src_1.default({cache:cache,getLiveKey:getLiveKey,getProxyKey:getProxyKey,openpgp:openpgp}),t.getKeysFromArmor("key-armor").then(function(){return setTimeout(e)}).catch(function(){return setTimeout(e.fail)})}),it("returns an {OpgpService} instance based on the given dependencies ",function(){expect(t).toEqual(e),expect(openpgp.key.readArmored).toHaveBeenCalledWith("key-armor"),expect(getLiveKey).toHaveBeenCalledWith(livekey.key),expect(cache.set).toHaveBeenCalledWith(livekey),expect(getProxyKey).toHaveBeenCalledWith("key-handle",livekey.bp)})}),describe("when called with { openpgp?: config } where config is a valid configuration object for `openpgp.config`",function(){var e,t;beforeEach(function(n){var i=src_1.default({openpgp:{debug:!0}});i.configure().then(function(e){return t=e}).catch(function(t){return e=t}).finally(function(){return setTimeout(n)})}),it("returns an {OpgpService} instance based on an openpgp instance with the given configuration",function(){expect(e).not.toBeDefined(),expect(t).toEqual(jasmine.objectContaining({debug:!0}))})})}),describe("OpgpService",function(){var e;beforeEach(function(){e=src_1.default({cache:cache,getLiveKey:getLiveKey,openpgp:openpgp})}),describe("configure (config?: Eventual<OpenpgpConfig>): Promise<OpenpgpConfig>",function(){var t,n;beforeEach(function(){openpgp.config={debug:!1,use_native:!1}}),describe("when called without config argument",function(){beforeEach(function(i){e.configure().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to the current openpgp configuration",function(){expect(t).not.toBeDefined(),expect(n).toEqual(openpgp.config)})}),describe("when called with an openpgp configuration object",function(){var i;beforeEach(function(){i={compression:42,debug:!0,versionstring:"test-version",use_native:"true",foo:"foo"}}),beforeEach(function(r){e.configure(i).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that resolves to the current openpgp configuration",function(){expect(t).not.toBeDefined(),expect(n).toEqual({compression:42,debug:!0,use_native:!1,versionstring:"test-version"})})})}),describe("getPublicKey (keyRef: Eventual<KeyRef>): Promise<OpgpProxyKey>",function(){describe("when given a valid private key handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey)}),beforeEach(function(i){e.isValidKeyHandle(Promise.resolve("valid-key-handle")).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("returns a Promise that resolves to `true`",function(){expect(n).toBe(!0),expect(t).not.toBeDefined()})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.isValidKeyHandle("stale-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that resolves to `false`",function(){expect(n).toBe(!1),expect(t).not.toBeDefined()})})}),describe("generateKey (user: Eventual<UserId[]|UserId>, opts?: Eventual<OpgpKeyOpts)>: Promise<OpgpProxyKey>",function(){it("delegates to the openpgp primitive",function(t){e.generateKey("john.doe@test.com",{passphrase:"secret passphrase"}).catch(function(){}).finally(function(){expect(openpgp.key.generate).toHaveBeenCalledWith(jasmine.objectContaining({userIds:jasmine.arrayContaining(["john.doe@test.com"]),passphrase:"secret passphrase",numBits:4096,unlocked:!1})),setTimeout(t)})}),describe("when the underlying openpgp primitive returns a newly generated key",function(){var t,n;beforeEach(function(){openpgp.key.generate.and.returnValue(Promise.resolve(livekey.key)),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(i){e.generateKey("john.doe@test.com").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("creates a new {OpgpLiveKey} instance from the new openpgp key",function(){expect(getLiveKey).toHaveBeenCalledWith(livekey.key)}),it("stores the new {OpgpLiveKey} instance in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(livekey)}),it("returns a Promise that resolves to the new {OpgpProxyKey} instance",function(){expect(n).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(n).toEqual(jasmine.objectContaining(livekey.bp)),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive throws an error",function(){var t,n;beforeEach(function(){openpgp.key.generate.and.throwError("boom")}),beforeEach(function(i){e.generateKey("john.doe@test.com").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to an {OpgpProxyKey} instance",function(){expect(t).toBeDefined(),expect(t.message).toBe("boom"),expect(n).not.toBeDefined()})}),describe("OgpgKeyOpts",function(){})}),describe("getPublicKey (keyRef: Eventual<KeyRef>): Promise<OpgpProxyKey>",function(){var t;beforeEach(function(){t={key:{},bp:{isPublic:!0,keys:[{id:"key-id"}],user:{ids:[]}}}}),describe("when given a valid private key handle string",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(livekey),cache.set.and.returnValue("public-key-handle"),livekey.toPublicKey.and.returnValue(Promise.resolve(t))}),beforeEach(function(t){e.getPublicKey(Promise.resolve("valid-private-key-handle")).then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-private-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.toPublicKey).toHaveBeenCalledWith()}),it("stores the new public {OpgpLiveKey} instance in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to a {OpgpProxyKey} instance of the public component of the referenced {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"public-key-handle"})),expect(i).toEqual(jasmine.objectContaining(livekey.bp)),expect(n).not.toBeDefined()})}),describe("when given a valid public key handle string",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(t)}),beforeEach(function(t){e.getPublicKey(Promise.resolve("valid-private-key-handle")).then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-private-key-handle")}),it("does not delegate to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.toPublicKey).not.toHaveBeenCalled()}),it("returns a Promise that resolves to the referenced {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"valid-private-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.getPublicKey("stale-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when the {OpgpLiveKey#toPublicKey} method rejects with an {Error}",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey),livekey.toPublicKey.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){e.getPublicKey("valid-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.toPublicKey).toHaveBeenCalledWith()}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#armor} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("getKeysFromArmor (armor: Eventual<string>, opts?: Eventual<OpgpKeyringOpts>): Promise<OpgpProxyKey[]|OpgpProxyKey>",function(){it("delegates to the openpgp primitive",function(t){e.getKeysFromArmor("key-armor").catch(function(){}).finally(function(){expect(openpgp.key.readArmored).toHaveBeenCalledWith("key-armor"),setTimeout(t)})}),describe("when the underlying openpgp primitive returns a single key",function(){var t,n;beforeEach(function(){openpgp.key.readArmored.and.returnValue({keys:[livekey.key]}),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(i){e.getKeysFromArmor("key-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("creates a new {OpgpLiveKey} instance from the openpgp key",function(){expect(getLiveKey).toHaveBeenCalledWith(livekey.key)}),it("stores the new {OpgpLiveKey} instance in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(livekey)}),it("returns a Promise that resolves to a corresponding {OpgpProxyKey} instance",function(){expect(n).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(n).toEqual(jasmine.objectContaining(livekey.bp)),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive returns multiple keys",function(){var t,n;beforeEach(function(){openpgp.key.readArmored.and.returnValue({keys:[livekey.key,livekey.key]}),getLiveKey.and.returnValue(livekey),cache.set.and.returnValue("key-handle")}),beforeEach(function(i){e.getKeysFromArmor("keys-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("creates new {OpgpLiveKey} instances from each openpgp key",function(){expect(getLiveKey.calls.allArgs()).toEqual([[livekey.key],[livekey.key]])}),it("stores the new {OpgpLiveKey} instances in the underlying cache",function(){expect(cache.set.calls.allArgs()).toEqual([[livekey],[livekey]])}),it("returns a Promise that resolves to corresponding {OpgpProxyKey} instances",function(){expect(n).toEqual(jasmine.any(Array)),expect(n.length).toBe(2),n.forEach(function(e){expect(e).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(e).toEqual(jasmine.objectContaining(livekey.bp))}),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive throws an error",function(){var t,n;beforeEach(function(){openpgp.key.readArmored.and.throwError("boom")}),beforeEach(function(i){e.getKeysFromArmor("key-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with the thrown error",function(){expect(t).toBeDefined(),expect(t.message).toBe("boom"),expect(n).not.toBeDefined()})})}),describe("getArmorFromKey (keyRef: Eventual<KeyRef>): Promise<string>",function(){describe("when given a valid key handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey),livekey.armor.and.returnValue("armor")}),beforeEach(function(i){e.getArmorFromKey(Promise.resolve("valid-key-handle")).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.armor).toHaveBeenCalledWith()}),it("returns a Promise that resolves to an armored {string} representation of the referenced {OpgpLiveKey} instance",function(){expect(n).toEqual("armor"),expect(t).not.toBeDefined()})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.getArmorFromKey("stale-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when the {OpgpLiveKey#armor} method rejects with an {Error}",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey),livekey.armor.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){e.getArmorFromKey("valid-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.armor).toHaveBeenCalledWith()}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#armor} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("unlock (keyRef: Eventual<KeyRef>, passphrase: Eventual<string>, opts?: Eventual<UnlockOpts>): Promise<OpgpProxyKey>",function(){describe("when given a valid handle string of a locked key and the correct passphrase",function(){var t,n,i;beforeEach(function(){livekey.bp.isLocked=!0,t={key:{},bp:{isLocked:!1,keys:[{id:"key-id"}],user:{ids:[]}}},cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.resolve(t)),cache.set.and.returnValue("unlocked-key-handle")}),beforeEach(function(t){e.unlock(Promise.resolve("valid-key-handle"),"secret passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("secret passphrase")}),it("stores the unlocked key in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to an {OpgpProxyKey} instance of the unlocked {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"unlocked-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when the referenced {OpgpLiveKey} instance is already unlocked",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.reject(new Error("key not locked")))}),beforeEach(function(i){e.unlock("unlocked-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("unlocked-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with a `key not locked` {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not locked")})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.unlock("stale-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given an incorrect passphrase",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.reject(new Error("fail to unlock key")))}),beforeEach(function(i){e.unlock("valid-key-handle","incorrect passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("incorrect passphrase")}),it("returns a Promise that rejects with a `fail to unlock key` {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("fail to unlock key")})}),describe("when the {OpgpLiveKey#unlock} method rejects with an {Error}",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey),livekey.unlock.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){e.unlock("valid-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.unlock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("lock (keyRef: Eventual<KeyRef>, passphrase: Eventual<string>, opts?: Eventual<UnlockOpts>): Promise<OpgpProxyKey>",function(){describe("when given a valid handle string of an unlocked key and a passphrase string",function(){var t,n,i;beforeEach(function(){livekey.bp.isLocked=!1,t={key:{},bp:{isLocked:!0,keys:[{id:"key-id"}],user:{ids:[]}}},cache.get.and.returnValue(livekey),livekey.lock.and.returnValue(Promise.resolve(t)),cache.set.and.returnValue("locked-key-handle")}),beforeEach(function(t){e.lock(Promise.resolve("unlocked-key-handle"),"secret passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("unlocked-key-handle")}),it("invalidates the original {OpgpLiveKey} from the cache",function(){expect(cache.del).toHaveBeenCalledWith("unlocked-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.lock).toHaveBeenCalledWith("secret passphrase")}),it("stores the unlocked key in the underlying cache",function(){expect(cache.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to an {OpgpProxyKey} instance of the locked {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"locked-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when the referenced {OpgpLiveKey} instance is already locked",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey)}),beforeEach(function(i){e.lock("locked-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("locked-key-handle")}),it("does not invalidate the original {OpgpLiveKey} from the cache",function(){expect(cache.del).not.toHaveBeenCalled()}),it("does notdelegate to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.lock).not.toHaveBeenCalled()}),it("returns a Promise that rejects with a `key not unlocked` {Error} from the {OpgpLiveKey#lock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not unlocked")})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.lock("stale-key-handle","secret passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when the {OpgpLiveKey#lock} method rejects with an {Error}",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey),livekey.lock.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){e.lock("valid-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("invalidates the original {OpgpLiveKey} from the cache",function(){expect(cache.del).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(livekey.lock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#lock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("encrypt (keyRefs: Eventual<KeyRefMap>, plain: Eventual<string>, opts?: Eventual<EncryptOpts>): Promise<string>",function(){describe("when given a valid plain text string, and valid handles of valid public cipher and private authentication keys",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.encrypt.and.returnValue({data:"cipher text"})}),beforeEach(function(i){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.encrypt(Promise.resolve(r),"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-auth-key-handle"],["valid-cipher-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.encrypt).toHaveBeenCalledWith(jasmine.objectContaining({data:"plain text",publicKeys:[livekey.key],privateKeys:[livekey.key]}))}),it("returns a Promise that resolves to an armor string of the given text string encrypted with the referenced cipher {OpgpLiveKey} instances and signed with the referenced authentication {OpgpLiveKey} instances ",function(){expect(n).toBe("cipher text"),expect(t).not.toBeDefined()})}),describe("when given a valid plain text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){var r={cipher:"stale-key-handle",auth:"stale-key-handle"};e.encrypt(r,"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.encrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given a valid plain text string, and a valid handle string of a locked private key",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey)}),beforeEach(function(i){var r={cipher:"cipher-key-handle",auth:"locked-auth-key-handle"};e.encrypt(r,"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("locked-auth-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.encrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `private key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("private key not unlocked")})}),describe("when the underlying openpgp primitive rejects with an {Error}",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.encrypt.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(i){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.encrypt(r,"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-auth-key-handle"],["valid-cipher-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.encrypt).toHaveBeenCalledWith(jasmine.objectContaining({data:"plain text",publicKeys:[livekey.key],privateKeys:[livekey.key]}))}),it("returns a Promise that rejects with the {Error} from the openpgp primitive",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("decrypt (keyRefs: Eventual<KeyRefMap>, cipher: Eventual<string>, opts?: Eventual<DecryptOpts>): Promise<string>",function(){var t;beforeEach(function(){t={}}),describe("when given a valid cipher text string, and valid handles of valid public authentication and a private cipher key",function(){var n,i;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),openpgp.decrypt.and.returnValue({data:"plain text"})}),beforeEach(function(t){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.decrypt(Promise.resolve(r),"cipher text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-cipher-key-handle"],["valid-auth-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("cipher text"),expect(openpgp.decrypt).toHaveBeenCalledWith(jasmine.objectContaining({message:t,publicKeys:[livekey.key],privateKey:livekey.key}))}),it("returns a Promise that resolves to an armor string of the given text string decrypted with the referenced cipher {OpgpLiveKey} instance and authenticated with the referenced authentication {OpgpLiveKey} instances ",function(){expect(i).toBe("plain text"),expect(n).not.toBeDefined()})}),describe("when given a valid plain text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){var r={cipher:"stale-key-handle",auth:"stale-key-handle"};e.decrypt(r,"cipher text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled(),expect(openpgp.decrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given a valid plain text string, and a valid handle string of a locked private key",function(){var t,n;beforeEach(function(){livekey.bp.isLocked=!0,cache.get.and.returnValue(livekey);
}),beforeEach(function(i){var r={cipher:"locked-cipher-key-handle",auth:"auth-key-handle"};e.decrypt(r,"cipher text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("locked-cipher-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled(),expect(openpgp.decrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `private key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("private key not unlocked")})}),describe("when the underlying openpgp primitive rejects with an {Error}",function(){var n,i;beforeEach(function(){livekey.bp.isLocked=!1,cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),openpgp.decrypt.and.returnValue(Promise.reject(new Error("boom")))}),beforeEach(function(t){var r={cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"};e.decrypt(r,"cipher text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(cache.get.calls.allArgs()).toEqual([["valid-cipher-key-handle"],["valid-auth-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("cipher text"),expect(openpgp.decrypt).toHaveBeenCalledWith(jasmine.objectContaining({message:t,publicKeys:[livekey.key],privateKey:livekey.key}))}),it("returns a Promise that rejects with the {Error} from the openpgp primitive",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("boom")})})}),describe("sign (keyRefs: Eventual<KeyRef[]|KeyRef>, text: Eventual<string>, opts?: Eventual<SignOpts>): Promise<string>",function(){var t;beforeEach(function(){t=jasmine.createSpyObj("message",["sign","armor"])}),describe("when given a text string and a valid handle string that is not stale",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(livekey),openpgp.message.fromText.and.returnValue(t),t.sign.and.returnValue(t),t.armor.and.returnValue("signed-armor-text")}),beforeEach(function(t){e.sign(Promise.resolve("valid-key-handle"),"plain text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.fromText).toHaveBeenCalledWith("plain text"),expect(t.sign).toHaveBeenCalledWith([livekey.key]),expect(t.armor).toHaveBeenCalledWith()}),it("returns a Promise that resolves to an armor string of the given text string signed with the referenced {OpgpLiveKey} instance ",function(){expect(i).toBe("signed-armor-text"),expect(n).not.toBeDefined()})}),describe("when given a text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.sign("stale-key-handle","plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.fromText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given non-compliant arguments",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey)}),beforeEach(function(i){var r=getInvalidAuthArgs();Promise.any(r.map(function(t){return e.sign.apply(e,t)})).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){cache.get.calls.allArgs().forEach(function(e){return expect(e).toEqual(["compliant handle"])})}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.fromText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` or an `invalid text: not a string` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Promise.AggregateError)),t.forEach(function(e){expect(e).toEqual(jasmine.any(Error)),expect(e.message).toEqual(jasmine.stringMatching(/invalid key reference: not a string or stale|invalid text: not a string/))})})})}),describe("verify (keyRefs: Eventual<KeyRef[]|KeyRef>, armor: Eventual<string>, opts?: Eventual<VerifyOpts>): Promise<string>",function(){var t;beforeEach(function(){t=jasmine.createSpyObj("message",["verify","getText"])}),describe("when given a signed armor text string and the valid handle string of the corresponding authentication key",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),t.verify.and.returnValue([{keyid:"keyid",valid:!0}]),t.getText.and.returnValue("plain-text")}),beforeEach(function(t){e.verify(Promise.resolve("valid-auth-key-handle"),"signed armor text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("valid-auth-key-handle")}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("signed armor text"),expect(t.verify).toHaveBeenCalledWith([livekey.key]),expect(t.getText).toHaveBeenCalledWith()}),it("returns a Promise that resolves to the plain text string",function(){expect(i).toBe("plain-text"),expect(n).not.toBeDefined()})}),describe("when given a signed armor text string and a valid handle string of the wrong authentication key",function(){var n,i;beforeEach(function(){cache.get.and.returnValue(livekey),openpgp.message.readArmored.and.returnValue(t),t.verify.and.returnValue([{keyid:"verified-keyid",valid:!0},{keyid:"wrong-keyid",valid:!1},{keyid:"another-wrong-keyid",valid:!1}])}),beforeEach(function(t){e.verify(["correct-key-handle","wrong-key-handle","another-wrong-key-handle"],"signed armor text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get.calls.allArgs()).toEqual([["correct-key-handle"],["wrong-key-handle"],["another-wrong-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(openpgp.message.readArmored).toHaveBeenCalledWith("signed armor text"),expect(t.verify).toHaveBeenCalledWith([livekey.key,livekey.key,livekey.key]),expect(t.getText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an {Error} containing a message with a trailing list of the key IDs that fail authentication",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("authentication failed: wrong-keyid,another-wrong-keyid")})}),describe("when given a signed armor text string and a stale handle string",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(void 0)}),beforeEach(function(i){e.verify("stale-key-handle","signed armor text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(cache.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given non-compliant arguments",function(){var t,n;beforeEach(function(){cache.get.and.returnValue(livekey)}),beforeEach(function(i){var r=getInvalidAuthArgs();Promise.any(r.map(function(t){return e.verify.apply(e,t)})).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("attempts to retrieve the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){cache.get.calls.allArgs().forEach(function(e){return expect(e).toEqual(["compliant handle"])})}),it("does not delegate to the openpgp primitive",function(){expect(openpgp.message.readArmored).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` or an `invalid armor: not a string` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Promise.AggregateError)),t.forEach(function(e){expect(e).toEqual(jasmine.any(Error)),expect(e.message).toEqual(jasmine.stringMatching(/invalid key reference: not a string or stale|invalid armor: not a string/))})})})})});
},{"../src":3,"bluebird":undefined}],2:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var tslib_1=require("tslib"),live_key_1=require("../src/live-key"),base64=require("base64-js"),getLiveKey,openpgp,key,subkeys,packets,msg,blueprint,livekeyInterface,cloneKey;beforeEach(function(){openpgp={crypto:{hash:jasmine.createSpyObj("hash",["sha256"])},key:jasmine.createSpyObj("key",["readArmored"]),message:jasmine.createSpyObj("message",["fromText","readArmored"])},key=jasmine.createSpyObj("key",["armor","toPublic","getAllKeyPackets","isPublic","getUserIds","getSigningKeyPacket","getEncryptionKeyPacket","verifyPrimaryKey","getExpirationTime","encrypt","decrypt"]),packets=[0,1,2,3].map(function(e){return jasmine.createSpyObj("packet"+e,["getFingerprint","writeOld"])}),subkeys=[0,1,2].map(function(e){return jasmine.createSpyObj("subkey"+e,["isValidEncryptionKey","isValidSigningKey","verify","getExpirationTime"])}),msg=jasmine.createSpyObj("msg",["sign","verify"]),key.armor.and.returnValue("key-armor"),key.getAllKeyPackets.and.returnValue(packets),key.isPublic.and.returnValue(!1),key.getUserIds.and.returnValue(["user@test.io"]),key.getSigningKeyPacket.and.returnValue(packets[0]),key.getEncryptionKeyPacket.and.returnValue(packets[0]),key.verifyPrimaryKey.and.returnValue(6510),packets.forEach(function(e,t){e.getFingerprint.and.returnValue(t.toString()),e.writeOld.and.returnValue(["old"+t])}),subkeys.forEach(function(e,t){e.isValidEncryptionKey.and.returnValue(!0),e.isValidSigningKey.and.returnValue(!0),e.verify.and.returnValue(6511+t),e.getExpirationTime.and.returnValue(new Date(1984-t))}),key.primaryKey={isDecrypted:!1},key.subKeys=subkeys,cloneKey=function(e){var t=tslib_1.__assign({},e);return t.primaryKey={isDecrypted:e.primaryKey.isDecrypted},t.subKeys=e.subKeys.slice(),t},openpgp.crypto.hash.sha256.and.returnValue(base64.toByteArray("c2hhMjU2")),openpgp.key.readArmored.and.callFake(function(){return{keys:[cloneKey(key)]}}),openpgp.message.readArmored.and.returnValue(msg),openpgp.message.fromText.and.returnValue(msg),livekeyInterface={key:key,bp:jasmine.any(Object),armor:jasmine.any(Function),unlock:jasmine.any(Function),lock:jasmine.any(Function),sign:jasmine.any(Function),verify:jasmine.any(Function)},blueprint={isLocked:!0,isPublic:!1,keys:[0,1,2,3].map(function(e){return{isAuth:!0,isCiph:!0,expires:e?1985-e:1/0,fingerprint:e.toString(),hash:"c2hhMjU2",status:6510+e}}),user:{ids:["user@test.io"]}}}),beforeEach(function(){getLiveKey=live_key_1.default({openpgp:openpgp})}),describe("default export: getLiveKeyFactory (config: {openpgp:any}): LiveKeyFactory",function(){it("returns a {LiveKey} factory when given an instance of openpgp",function(){expect(getLiveKey).toEqual(jasmine.any(Function))})}),describe("LiveKeyFactory: getLiveKey (key: any, opts?: LiveKeyFactoryOpts): OpgpLiveKey",function(){var e;beforeEach(function(){e=getLiveKey(key)}),it("returns a {OpgpLiveKey} instance that wraps the given openpgp key",function(){expect(e).toEqual(jasmine.objectContaining(livekeyInterface))})}),describe("OpgpLiveKey",function(){var e;beforeEach(function(){e=getLiveKey(key)}),describe("bp: OpgpKeyBlueprint",function(){var t;beforeEach(function(){t=e.bp}),it("is a blueprint of the openpgp wrapped in the {OpgpLiveKey} instance:\n{\n  isLocked: boolean,\n  isPublic: boolean,\n  keys: OpgpKeyId[],\n  user: { ids: string[] }\n}\nwhere each {OpgpKeyId} element in `keys` is a blueprint of the corresponding key component:\n{\n  isAuth: boolean,\n  isCiph: boolean,\n  expires: number,\n  fingerprint: string,\n  hash: string,\n  status: number\n}",function(){expect(t).toEqual(blueprint)})}),describe("armor (): Promise<string>",function(){describe("when the openpgp primitive succeeds",function(){var t,n;beforeEach(function(i){e.armor().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to an armored string representation of the wrapped openpgp key when the openpgp primitive succeeds",function(){expect(key.armor).toHaveBeenCalled(),expect(n).toBe("key-armor"),expect(t).not.toBeDefined()})}),describe("when the openpgp primitive fails",function(){var t,n;beforeEach(function(i){key.armor.and.throwError("boom"),e.armor().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with the error from the openpgp primitive when it fails",function(){expect(key.armor).toHaveBeenCalled(),expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("boom")})})}),describe("toPublicKey (): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){t=cloneKey(key),t.isPublic=jasmine.createSpy("armor").and.returnValue(!0)}),describe("when this {LiveKey} wraps a private openpgp key",function(){var n,i;beforeEach(function(r){livekeyInterface.key=t,key.toPublic.and.returnValue(t),e.toPublicKey().then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(r)})}),it("delegates to the underlying openpgp primitive",function(){expect(key.toPublic).toHaveBeenCalledWith()}),it("returns a Promise that resolves to a {OpgpLiveKey} instance that wraps the public openpgp key of the wrapped openpgp key of this {LiveKey}",function(){expect(i).toEqual(jasmine.objectContaining(livekeyInterface)),expect(n).not.toBeDefined()})}),describe("when this {LiveKey} wraps a public openpgp key",function(){var e,n,i;beforeEach(function(r){i=getLiveKey(t),i.toPublicKey().then(function(e){return n=e}).catch(function(t){return e=t}).finally(function(){return setTimeout(r)})}),it("does not delegate to the underlying openpgp primitive",function(){expect(key.toPublic).not.toHaveBeenCalled()}),it("returns this {OpgpLiveKey} instance ",function(){expect(n).toEqual(i),expect(e).not.toBeDefined()})}),describe("when the openpgp primitive fails",function(){var t,n;beforeEach(function(i){key.toPublic.and.throwError("boom"),e.toPublicKey().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with the error from the openpgp primitive",function(){expect(key.toPublic).toHaveBeenCalled(),expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("boom")})})}),describe("unlock (passphrase: string, opts?: LiveKeyUnlockOpts): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){t=cloneKey(key),t.primaryKey.isDecrypted=!0}),describe("when given the correct passphrase",function(){var n,i;beforeEach(function(r){openpgp.key.readArmored.and.callFake(function(){var e=cloneKey(t);return e.decrypt=jasmine.createSpy("decrypt").and.returnValue(!0),{keys:[e]}}),e.unlock("correct passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that resolves to a new, unlocked {OpgpLiveKey} instance",function(){expect(n).not.toBeDefined(),expect(i).not.toBe(e),expect(i.bp.isLocked).toBe(!1)}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0),expect(e.key.decrypt).not.toHaveBeenCalled()})}),describe("when given an incorrect passphrase",function(){var t,n;beforeEach(function(i){key.decrypt.and.returnValue(!1),e.unlock("incorrect passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with a `fail to unlock key` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("fail to unlock key")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0)})}),describe("when its {OpgpLiveKey} is already unlocked",function(){var n,i;beforeEach(function(r){e=getLiveKey(t),e.unlock("passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with a `key not locked` {Error}",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("key not locked")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(t),expect(e.key.primaryKey.isDecrypted).toBe(!0),expect(e.bp.isLocked).toBe(!1)})}),describe("when the openpgp primitive throws an exception",function(){var t,n;beforeEach(function(i){key.decrypt.and.throwError("boom"),e.unlock("passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with the corresponding error",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0)})})}),describe("lock (passphrase: string, opts?: LiveKeyUnlockOpts): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){t=cloneKey(key),t.primaryKey.isDecrypted=!0}),describe("when given a passphrase",function(){var n,i;beforeEach(function(r){t.encrypt=jasmine.createSpy("encrypt").and.callFake(function(){return t.primaryKey.isDecrypted=!1}),e=getLiveKey(t),e.lock("passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that resolves to a new, locked {OpgpLiveKey} instance",function(){expect(n).not.toBeDefined(),expect(i).not.toBe(e),expect(i.bp.isLocked).toBe(!0)}),it("invalidates its {OpgpLiveKey} instance",function(){expect(e.key).not.toBeDefined()})}),describe("when its {OpgpLiveKey} is already locked",function(){var t,n;beforeEach(function(i){e.lock("passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that rejects with a `key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not unlocked")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(key),expect(e.key.primaryKey.isDecrypted).toBe(!1),expect(e.bp.isLocked).toBe(!0)})}),describe("when the openpgp primitive throws an exception",function(){var n,i;beforeEach(function(r){key.encrypt.and.throwError("boom"),e=getLiveKey(t),e.lock("incorrect passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with the corresponding error",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("boom")}),it("invalidates its {OpgpLiveKey} instance",function(){expect(e.key).not.toBeDefined()})})})});

},{"../src/live-key":4,"base64-js":undefined,"tslib":undefined}],3:[function(require,module,exports){
"use strict";function reject(e){return Promise.reject(new Error(e))}function getHandle(e){var r=utils_1.isString(e)?e:!!e&&e.handle;return utils_1.isString(r)&&r}function getOpenpgp(e){if(isOpenpgp(e))return e;var r=require("openpgp");return configureOpenpgp(r,OPENPGP_CONFIG_DEFAULTS,e)}function isOpenpgp(e){return!!e&&["config","crypto","key","message"].every(function(r){return!!e[r]})&&[e.encrypt,e.decrypt,e.crypto.hash&&e.crypto.hash.sha256,e.key.readArmored,e.key.generate,e.message.fromText,e.message.readArmored].every(function(e){return utils_1.isFunction(e)})}function configureOpenpgp(e){for(var r=[],t=1;t<arguments.length;t++)r[t-1]=arguments[t];var n=[e.config].concat(r.map(toValidOpenpgpConfig));return tslib_2.__assign.apply(Object,n),e}function toValidOpenpgpConfig(e){return Object.keys(e||{}).reduce(function(r,t){var n=OPENPGP_CONFIG_INTERFACE[t];if(!n)return r;var i=e[t];return n(i)?(r[t]=i,r):r},{})}function isValidUser(e){return Array.isArray(e)?e.every(isValidUser):utils_1.isString(e)||!!e&&utils_1.isString(e.email)&&(!name||utils_1.isString(e.name))}function isValidKeyOpts(e){return!e||(!e.passphrase||utils_1.isString(e.passphrase))&&(!e.size||utils_1.isNumber(e.size))&&(!e.unlocked||utils_1.isBoolean(e.unlocked))}function toKeySpec(e,r){var t=tslib_1.__assign({user:[].concat(e)},OPGP_KEY_DEFAULTS,r),n={userIds:t.user,numBits:t.size,unlocked:t.unlocked};return t.passphrase&&(n.passphrase=t.passphrase),n}Object.defineProperty(exports,"__esModule",{value:!0});var tslib_1=require("tslib"),live_key_1=require("./live-key"),proxy_key_1=require("./proxy-key"),utils_1=require("./utils"),csrkey_cache_1=require("csrkey-cache"),Promise=require("bluebird"),resolve_call_1=require("resolve-call"),resolve=resolve_call_1.default({Promise:Promise}),tslib_2=require("tslib"),OPGP_KEY_DEFAULTS={size:4096,unlocked:!1},OpgpServiceClass=function(){function e(e,r,t,n){this.cache=e,this.getLiveKey=r,this.getProxyKey=t,this.openpgp=n}return e.prototype.configure=function(e){var r=configureOpenpgp(this.openpgp,e);return Promise.resolve(tslib_1.__assign({},r.config))},e.prototype.isValidKeyHandle=function(e){var r=this;return Promise.try(function(){return r.getCachedLiveKey(e)}).catch(function(e){return!1}).then(Boolean)},e.prototype.generateKey=function(e,r){var t=this;return isValidUser(e)?isValidKeyOpts(r)?Promise.try(function(){return t.openpgp.key.generate(toKeySpec(e,r))}).then(function(e){return t.cacheAndProxyKey(t.getLiveKey(e))}):reject("invalid key options"):reject("invalid user")},e.prototype.getPublicKey=function(e){var r=this;return Promise.try(function(){return r.getCachedLiveKey(e)}).then(function(t){return t.bp.isPublic?r.getProxyKey(getHandle(e),t.bp):t.toPublicKey().then(function(e){return r.cacheAndProxyKey(e)})})},e.prototype.getKeysFromArmor=function(e,r){var t=this;return utils_1.isString(e)?Promise.try(function(){var r=t.openpgp.key.readArmored(e).keys.map(function(e){return t.cacheAndProxyKey(t.getLiveKey(e))});return r.length>1?r:r[0]}):reject("invalid armor: not a string")},e.prototype.getArmorFromKey=function(e){var r=this;return Promise.try(function(){return r.getCachedLiveKey(e).armor()})},e.prototype.unlock=function(e,r,t){var n=this;return utils_1.isString(r)?Promise.try(function(){return n.getCachedLiveKey(e).unlock(r)}).then(function(e){return n.cacheAndProxyKey(e)}):reject("invalid passphrase: not a string")},e.prototype.lock=function(e,r,t){var n=this;return utils_1.isString(r)?Promise.try(function(){var t=n.getCachedLiveKey(e);if(t.bp.isLocked)return reject("key not unlocked");var i=getHandle(e);return n.cache.del(i),t.lock(r)}).then(function(e){return n.cacheAndProxyKey(e)}):reject("invalid passphrase: not a string")},e.prototype.encrypt=function(e,r,t){var n=this;return utils_1.isString(r)?Promise.try(function(){return n.openpgp.encrypt({privateKeys:n.getCachedPrivateOpenpgpKeys(e.auth),publicKeys:n.getCachedOpenpgpKeys(e.cipher),data:r})}).get("data"):reject("invalid plain text: not a string")},e.prototype.decrypt=function(e,r,t){var n=this;return utils_1.isString(r)?Promise.try(function(){return n.openpgp.decrypt({privateKey:n.getCachedPrivateOpenpgpKeys(e.cipher)[0],publicKeys:n.getCachedOpenpgpKeys(e.auth),message:n.openpgp.message.readArmored(r)})}).get("data"):reject("invalid cipher: not a string")},e.prototype.sign=function(e,r,t){var n=this;return Promise.try(function(){var t=n.getCachedOpenpgpKeys(e);if(!utils_1.isString(r))return reject("invalid text: not a string");var i=n.openpgp.message.fromText(r);return i.sign(t).armor()})},e.prototype.verify=function(e,r,t){var n=this;return Promise.try(function(){var t=n.getCachedOpenpgpKeys(e);if(!utils_1.isString(r))return reject("invalid armor: not a string");var i=n.openpgp.message.readArmored(r),o=i.verify(t).filter(function(e){return!e.valid}).map(function(e){return e.keyid}).join();return o?reject("authentication failed: "+o):i.getText()})},e.prototype.getCachedLiveKey=function(e){var r=getHandle(e),t=r&&this.cache.get(r);if(!t)throw new Error("invalid key reference: not a string or stale");return t},e.prototype.getCachedLiveKeys=function(e){var r=this,t=[].concat(e);if(!t.length)throw new Error("no key references");return t.map(function(e){return r.getCachedLiveKey(e)})},e.prototype.getCachedOpenpgpKeys=function(e){return this.getCachedLiveKeys(e).map(function(e){return e.key})},e.prototype.getCachedPrivateOpenpgpKeys=function(e){var r=this.getCachedLiveKeys(e);if(r.some(function(e){return e.bp.isLocked}))throw new Error("private key not unlocked");return r.map(function(e){return e.key})},e.prototype.cacheAndProxyKey=function(e){var r=this.cache.set(e);if(!r)throw new Error("fail to cache key");return this.getProxyKey(r,e.bp)},e}();OpgpServiceClass.getInstance=function(e){var r=tslib_1.__assign({},e),t=r.cache||csrkey_cache_1.default(),n=getOpenpgp(r.openpgp),i=r.getLiveKey||live_key_1.default({openpgp:n}),o=new OpgpServiceClass(t,i,r.getProxyKey||proxy_key_1.default,n);return OpgpServiceClass.PUBLIC_METHODS.reduce(function(e,r){return e[r]=resolve(o[r]).bind(o),e},{})},OpgpServiceClass.PUBLIC_METHODS=["configure","isValidKeyHandle","generateKey","getPublicKey","getKeysFromArmor","getArmorFromKey","unlock","lock","encrypt","decrypt","sign","verify"];var OPENPGP_CONFIG_DEFAULTS={aead_protect:!0},OPENPGP_CONFIG_INTERFACE={prefer_hash_algorithm:utils_1.isNumber,encryption_cipher:utils_1.isNumber,compression:utils_1.isNumber,aead_protect:utils_1.isBoolean,integrity_protect:utils_1.isBoolean,ignore_mdc_error:utils_1.isBoolean,rsa_blinding:utils_1.isBoolean,use_native:utils_1.isBoolean,zero_copy:utils_1.isBoolean,debug:utils_1.isBoolean,show_version:utils_1.isBoolean,show_comment:utils_1.isBoolean,versionstring:utils_1.isString,commentstring:utils_1.isString,keyserver:utils_1.isString,node_store:utils_1.isString},OPENPGP_CONFIG_KEYS=Object.keys(OPENPGP_CONFIG_INTERFACE),getOpgpService=OpgpServiceClass.getInstance;exports.default=getOpgpService;

},{"./live-key":4,"./proxy-key":5,"./utils":6,"bluebird":undefined,"csrkey-cache":undefined,"openpgp":undefined,"resolve-call":undefined,"tslib":undefined}],4:[function(require,module,exports){
"use strict";function isLocked(e){return!e.primaryKey.isDecrypted}function getExpiry(e){var t=e.getExpirationTime();return t?t.getTime():1/0}Object.defineProperty(exports,"__esModule",{value:!0});var tslib_1=require("tslib"),base64=require("base64-js"),Promise=require("bluebird"),LiveKeyClass=function(){function e(e,t,r){this.utils=e,this.key=t,this.bp=r}return e.prototype.armor=function(){var e=this;return Promise.try(function(){return e.key.armor()})},e.prototype.toPublicKey=function(){var t=this;return this.bp.isPublic?Promise.resolve(this):Promise.try(function(){return t.key.toPublic()}).then(function(r){return new e(t.utils,r,t.utils.getKeyBlueprint(r))})},e.prototype.unlock=function(t,r){var i=this;return this.bp.isLocked?Promise.try(function(){var r=i.utils.cloneKey(i.key),n=r.decrypt(t);return n?e.getInstance(i.utils,r):Promise.reject(new Error("fail to unlock key"))}):Promise.reject(new Error("key not locked"))},e.prototype.lock=function(t,r){var i=this;return this.bp.isLocked?Promise.reject(new Error("key not unlocked")):Promise.try(function(){return i.key.encrypt(t),e.getInstance(i.utils,i.key)}).finally(function(){return delete i.key})},e.prototype.sign=function(e,t){var r=this;return Promise.try(function(){return r.utils.openpgp.message.fromText(e).sign([r.key]).armor()})},e.prototype.verify=function(e,t){var r=this;return Promise.try(function(){var t=r.utils.openpgp.message.readArmored(e),i=t.verify([r.key]);return!!i.length&&i[0].valid&&t.getText()})},e.getInstance=function(t,r,i){var n=t.getKeyBlueprint(r);return new e(t,r,n)},e}();LiveKeyClass.getFactory=function(e){var t=new OpenpgpKeyUtils(e.openpgp);return LiveKeyClass.getInstance.bind(LiveKeyClass,t)};var OpenpgpKeyUtils=function(){function e(e){this.openpgp=e}return e.prototype.getKeyBlueprint=function(e){var t=this,r=e.getAllKeyPackets(),i=this.getOpgpKeyId(e,r[0]),n=r.slice(1).map(function(r,i){return t.getOpgpKeyId(e,r,i)});return{isLocked:isLocked(e),isPublic:e.isPublic(),keys:[i].concat(n),user:{ids:e.getUserIds()}}},e.prototype.getHashes=function(e){return{hash:this.getFingerprintHash(e),fingerprint:e.getFingerprint()}},e.prototype.getPrimaryKeyType=function(e){var t=this.cloneKey(e);return t.subKeys=null,{isAuth:!!t.getSigningKeyPacket(),isCiph:!!t.getEncryptionKeyPacket()}},e.prototype.getFingerprintHash=function(e,t){var r=e.writeOld(),i=this.openpgp.crypto.hash[t&&t.hash||"sha256"](r);return base64.fromByteArray(i)},e.prototype.cloneKey=function(e){return this.openpgp.key.readArmored(e.armor()).keys[0]},e.prototype.getOpgpKeyId=function(e,t,r){return"undefined"==typeof r?this.getPrimaryOpgpKeyId(e,t):this.getSubkeyOpgpKeyId(e,t,r)},e.prototype.getPrimaryOpgpKeyId=function(e,t){return tslib_1.__assign({},this.getHashes(t),this.getPrimaryKeyType(e),{status:e.verifyPrimaryKey(),expires:getExpiry(e)})},e.prototype.getSubkeyOpgpKeyId=function(e,t,r){var i=e.subKeys[r];return tslib_1.__assign({},this.getHashes(t),{isCiph:i.isValidEncryptionKey(e.primaryKey),isAuth:i.isValidSigningKey(e.primaryKey),status:i.verify(e.primaryKey),expires:getExpiry(i)})},e}(),getLiveKeyFactory=LiveKeyClass.getFactory;exports.default=getLiveKeyFactory;
},{"base64-js":undefined,"bluebird":undefined,"tslib":undefined}],5:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var tslib_1=require("tslib"),getProxyKey=function(e,s){var r=tslib_1.__assign({handle:e},s);return r.keys=s.keys.map(function(e){return tslib_1.__assign({},e)}),r.user={ids:s.user.ids.slice()},r};exports.default=getProxyKey;
},{"tslib":undefined}],6:[function(require,module,exports){
"use strict";function isString(e){return"string"==typeof(e&&e.valueOf())}function isNumber(e){return"number"==typeof(e&&e.valueOf())}function isBoolean(e){return"boolean"==typeof(e&&e.valueOf())}function isFunction(e){return"function"==typeof e}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isString=isString,exports.isNumber=isNumber,exports.isBoolean=isBoolean,exports.isFunction=isFunction;

},{}]},{},[1,2]);
