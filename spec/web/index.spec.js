require=function(){return function e(t,n,r){function i(a,c){if(!n[a]){if(!t[a]){var u="function"==typeof require&&require;if(!c&&u)return u(a,!0);if(o)return o(a,!0);var s=new Error("Cannot find module '"+a+"'");throw s.code="MODULE_NOT_FOUND",s}var p=n[a]={exports:{}};t[a][0].call(p.exports,function(e){return i(t[a][1][e]||e)},p,p.exports,e,t,n,r)}return n[a].exports}for(var o="function"==typeof require&&require,a=0;a<r.length;a++)i(r[a]);return i}}()({1:[function(e,t,n){var r,i,o=t.exports={};function a(){throw new Error("setTimeout has not been defined")}function c(){throw new Error("clearTimeout has not been defined")}function u(e){if(r===setTimeout)return setTimeout(e,0);if((r===a||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:a}catch(e){r=a}try{i="function"==typeof clearTimeout?clearTimeout:c}catch(e){i=c}}();var s,p=[],l=!1,f=-1;function h(){l&&s&&(l=!1,s.length?p=s.concat(p):f=-1,p.length&&d())}function d(){if(!l){var e=u(h);l=!0;for(var t=p.length;t;){for(s=p,p=[];++f<t;)s&&s[f].run();f=-1,t=p.length}s=null,l=!1,function(e){if(i===clearTimeout)return clearTimeout(e);if((i===c||!i)&&clearTimeout)return i=clearTimeout,clearTimeout(e);try{i(e)}catch(t){try{return i.call(null,e)}catch(t){return i.call(this,e)}}}(e)}}function y(e,t){this.fun=e,this.array=t}function g(){}o.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];p.push(new y(e,t)),1!==p.length||l||u(d)},y.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=g,o.addListener=g,o.once=g,o.off=g,o.removeListener=g,o.removeAllListeners=g,o.emit=g,o.prependListener=g,o.prependOnceListener=g,o.listeners=function(e){return[]},o.binding=function(e){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(e){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},{}],2:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r,i,o,a,c,u=e(4),s=e("bluebird");function p(){var e=[void 0,null,NaN,!0,42,"foo",["foo"],{foo:"foo"}].filter(function(e){return!function(e){return"string"==typeof e}(e)});return e.filter(function(e){return!Array.isArray(e)}).map(function(e){return[e,"compliant text"]}).concat(e.map(function(e){return[[e],"compliant text"]})).concat(e.map(function(e){return["compliant handle",e]}))}beforeEach(function(){r=jasmine.createSpyObj("cache",["set","del","get","has"]),i=jasmine.createSpy("getLiveKey"),o=jasmine.createSpy("getProxyKey"),a={config:{},crypto:{hash:jasmine.createSpyObj("hash",["sha256"])},key:jasmine.createSpyObj("key",["readArmored","generate"]),message:jasmine.createSpyObj("message",["fromText","readArmored"]),encrypt:jasmine.createSpy("encrypt"),decrypt:jasmine.createSpy("decrypt")},c={key:{},bp:{keys:[{id:"key-id"}],user:{ids:[]}},armor:jasmine.createSpy("armor"),toPublicKey:jasmine.createSpy("toPublicKey"),lock:jasmine.createSpy("lock"),unlock:jasmine.createSpy("unlock")}}),describe("default export: getOpgpService (config?: OpgpServiceFactoryConfig): OpgpService",function(){var e;beforeEach(function(){e=jasmine.objectContaining(["configure","generateKey","getPublicKey","getKeysFromArmor","getArmorFromKey","encrypt","decrypt","sign","verify"].reduce(function(e,t){return e[t]=jasmine.any(Function),e},{}))}),describe("when called without arguments",function(){var t;beforeEach(function(){t=u.default()}),it("returns an {OpgpService} instance",function(){expect(t).toEqual(e)})}),describe("when called with { cache?: CsrKeyCache<OpgpLiveKey>, getLiveKey?: LiveKeyFactory, getProxyKey?: ProxyKeyFactory, openpgp?: openpgp }",function(){var t;beforeEach(function(){a.key.readArmored.and.returnValue({keys:[c.key]}),i.and.returnValue(s.resolve(c)),r.set.and.returnValue("key-handle")}),beforeEach(function(e){(t=u.default({cache:r,getLiveKey:i,getProxyKey:o,openpgp:a})).getKeysFromArmor("key-armor").then(function(){return setTimeout(e)}).catch(function(){return setTimeout(e.fail)})}),it("returns an {OpgpService} instance based on the given dependencies ",function(){expect(t).toEqual(e),expect(a.key.readArmored).toHaveBeenCalledWith("key-armor"),expect(i).toHaveBeenCalledWith(c.key),expect(r.set).toHaveBeenCalledWith(c),expect(o).toHaveBeenCalledWith("key-handle",c.bp)})}),describe("when called with { openpgp?: config } where config is a valid configuration object for `openpgp.config`",function(){var e,t;beforeEach(function(n){u.default({openpgp:{debug:!0}}).configure().then(function(e){return t=e}).catch(function(t){return e=t}).finally(function(){return setTimeout(n)})}),it("returns an {OpgpService} instance based on an openpgp instance with the given configuration",function(){expect(e).not.toBeDefined(),expect(t).toEqual(jasmine.objectContaining({debug:!0}))})})}),describe("OpgpService",function(){var e;beforeEach(function(){e=u.default({cache:r,getLiveKey:i,openpgp:a})}),describe("configure (config?: Eventual<OpenpgpConfig>): Promise<OpenpgpConfig>",function(){var t,n;beforeEach(function(){a.config={debug:!1,use_native:!1}}),describe("when called without config argument",function(){beforeEach(function(r){e.configure().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that resolves to the current openpgp configuration",function(){expect(t).not.toBeDefined(),expect(n).toEqual(a.config)})}),describe("when called with an openpgp configuration object",function(){var r;beforeEach(function(){r={compression:42,debug:!0,versionstring:"test-version",use_native:"true",foo:"foo"}}),beforeEach(function(i){e.configure(r).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to the current openpgp configuration",function(){expect(t).not.toBeDefined(),expect(n).toEqual({compression:42,debug:!0,use_native:!1,versionstring:"test-version"})})})}),describe("getPublicKey (keyRef: Eventual<KeyRef>): Promise<OpgpProxyKey>",function(){describe("when given a valid private key handle string",function(){var t,n;beforeEach(function(){r.get.and.returnValue(c)}),beforeEach(function(r){e.isValidKeyHandle(s.resolve("valid-key-handle")).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("returns a Promise that resolves to `true`",function(){expect(n).toBe(!0),expect(t).not.toBeDefined()})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.isValidKeyHandle("stale-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that resolves to `false`",function(){expect(n).toBe(!1),expect(t).not.toBeDefined()})})}),describe("generateKey (user: Eventual<UserId[]|UserId>, opts?: Eventual<OpgpKeyOpts)>: Promise<OpgpProxyKey>",function(){it("delegates to the openpgp primitive",function(t){e.generateKey("john.doe@test.com",{passphrase:"secret passphrase"}).catch(function(){}).finally(function(){expect(a.key.generate).toHaveBeenCalledWith(jasmine.objectContaining({userIds:jasmine.arrayContaining(["john.doe@test.com"]),passphrase:"secret passphrase",numBits:4096,unlocked:!1})),setTimeout(t)})}),describe("when the underlying openpgp primitive returns a newly generated key",function(){var t,n;beforeEach(function(){a.key.generate.and.returnValue(s.resolve(c.key)),i.and.returnValue(s.resolve(c)),r.set.and.returnValue("key-handle")}),beforeEach(function(r){e.generateKey("john.doe@test.com").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("creates a new {OpgpLiveKey} instance from the new openpgp key",function(){expect(i).toHaveBeenCalledWith(c.key)}),it("stores the new {OpgpLiveKey} instance in the underlying cache",function(){expect(r.set).toHaveBeenCalledWith(c)}),it("returns a Promise that resolves to the new {OpgpProxyKey} instance",function(){expect(n).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(n).toEqual(jasmine.objectContaining(c.bp)),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive throws an error",function(){var t,n;beforeEach(function(){a.key.generate.and.throwError("boom")}),beforeEach(function(r){e.generateKey("john.doe@test.com").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that resolves to an {OpgpProxyKey} instance",function(){expect(t).toBeDefined(),expect(t.message).toBe("boom"),expect(n).not.toBeDefined()})}),describe("OgpgKeyOpts",function(){})}),describe("getPublicKey (keyRef: Eventual<KeyRef>): Promise<OpgpProxyKey>",function(){var t;beforeEach(function(){t={key:{},bp:{isPublic:!0,keys:[{id:"key-id"}],user:{ids:[]}}}}),describe("when given a valid private key handle string",function(){var n,i;beforeEach(function(){r.get.and.returnValue(c),r.set.and.returnValue("public-key-handle"),c.toPublicKey.and.returnValue(s.resolve(t))}),beforeEach(function(t){e.getPublicKey(s.resolve("valid-private-key-handle")).then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-private-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.toPublicKey).toHaveBeenCalledWith()}),it("stores the new public {OpgpLiveKey} instance in the underlying cache",function(){expect(r.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to a {OpgpProxyKey} instance of the public component of the referenced {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"public-key-handle"})),expect(i).toEqual(jasmine.objectContaining(c.bp)),expect(n).not.toBeDefined()})}),describe("when given a valid public key handle string",function(){var n,i;beforeEach(function(){r.get.and.returnValue(t)}),beforeEach(function(t){e.getPublicKey(s.resolve("valid-private-key-handle")).then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-private-key-handle")}),it("does not delegate to the retrieved {OpgpLiveKey} instance",function(){expect(c.toPublicKey).not.toHaveBeenCalled()}),it("returns a Promise that resolves to the referenced {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"valid-private-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.getPublicKey("stale-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when the {OpgpLiveKey#toPublicKey} method rejects with an {Error}",function(){var t,n;beforeEach(function(){r.get.and.returnValue(c),c.toPublicKey.and.returnValue(s.reject(new Error("boom")))}),beforeEach(function(r){e.getPublicKey("valid-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.toPublicKey).toHaveBeenCalledWith()}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#armor} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("getKeysFromArmor (armor: Eventual<string>, opts?: Eventual<OpgpKeyringOpts>): Promise<OpgpProxyKey[]|OpgpProxyKey>",function(){it("delegates to the openpgp primitive",function(t){e.getKeysFromArmor("key-armor").catch(function(){}).finally(function(){expect(a.key.readArmored).toHaveBeenCalledWith("key-armor"),setTimeout(t)})}),describe("when the underlying openpgp primitive returns a single key",function(){var t,n;beforeEach(function(){a.key.readArmored.and.returnValue({keys:[c.key]}),i.and.returnValue(s.resolve(c)),r.set.and.returnValue("key-handle")}),beforeEach(function(r){e.getKeysFromArmor("key-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("creates a new {OpgpLiveKey} instance from the openpgp key",function(){expect(i).toHaveBeenCalledWith(c.key)}),it("stores the new {OpgpLiveKey} instance in the underlying cache",function(){expect(r.set).toHaveBeenCalledWith(c)}),it("returns a Promise that resolves to a corresponding {OpgpProxyKey} instance",function(){expect(n).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(n).toEqual(jasmine.objectContaining(c.bp)),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive returns multiple keys",function(){var t,n;beforeEach(function(){a.key.readArmored.and.returnValue({keys:[c.key,c.key]}),i.and.returnValue(s.resolve(c)),r.set.and.returnValue("key-handle")}),beforeEach(function(r){e.getKeysFromArmor("keys-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("creates new {OpgpLiveKey} instances from each openpgp key",function(){expect(i.calls.allArgs()).toEqual([[c.key],[c.key]])}),it("stores the new {OpgpLiveKey} instances in the underlying cache",function(){expect(r.set.calls.allArgs()).toEqual([[c],[c]])}),it("returns a Promise that resolves to corresponding {OpgpProxyKey} instances",function(){expect(n).toEqual(jasmine.any(Array)),expect(n.length).toBe(2),n.forEach(function(e){expect(e).toEqual(jasmine.objectContaining({handle:"key-handle"})),expect(e).toEqual(jasmine.objectContaining(c.bp))}),expect(t).not.toBeDefined()})}),describe("when the underlying openpgp primitive throws an error",function(){var t,n;beforeEach(function(){a.key.readArmored.and.throwError("boom")}),beforeEach(function(r){e.getKeysFromArmor("key-armor").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with the thrown error",function(){expect(t).toBeDefined(),expect(t.message).toBe("boom"),expect(n).not.toBeDefined()})})}),describe("getArmorFromKey (keyRef: Eventual<KeyRef>): Promise<string>",function(){describe("when given a valid key handle string",function(){var t,n;beforeEach(function(){r.get.and.returnValue(c),c.armor.and.returnValue("armor")}),beforeEach(function(r){e.getArmorFromKey(s.resolve("valid-key-handle")).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.armor).toHaveBeenCalledWith()}),it("returns a Promise that resolves to an armored {string} representation of the referenced {OpgpLiveKey} instance",function(){expect(n).toEqual("armor"),expect(t).not.toBeDefined()})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.getArmorFromKey("stale-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when the {OpgpLiveKey#armor} method rejects with an {Error}",function(){var t,n;beforeEach(function(){r.get.and.returnValue(c),c.armor.and.returnValue(s.reject(new Error("boom")))}),beforeEach(function(r){e.getArmorFromKey("valid-key-handle").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.armor).toHaveBeenCalledWith()}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#armor} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("unlock (keyRef: Eventual<KeyRef>, passphrase: Eventual<string>, opts?: Eventual<UnlockOpts>): Promise<OpgpProxyKey>",function(){describe("when given a valid handle string of a locked key and the correct passphrase",function(){var t,n,i;beforeEach(function(){c.bp.isLocked=!0,t={key:{},bp:{isLocked:!1,keys:[{id:"key-id"}],user:{ids:[]}}},r.get.and.returnValue(c),c.unlock.and.returnValue(s.resolve(t)),r.set.and.returnValue("unlocked-key-handle")}),beforeEach(function(t){e.unlock(s.resolve("valid-key-handle"),"secret passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.unlock).toHaveBeenCalledWith("secret passphrase")}),it("stores the unlocked key in the underlying cache",function(){expect(r.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to an {OpgpProxyKey} instance of the unlocked {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"unlocked-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when the referenced {OpgpLiveKey} instance is already unlocked",function(){var t,n;beforeEach(function(){c.bp.isLocked=!1,r.get.and.returnValue(c),c.unlock.and.returnValue(s.reject(new Error("key not locked")))}),beforeEach(function(r){e.unlock("unlocked-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("unlocked-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.unlock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with a `key not locked` {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not locked")})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.unlock("stale-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given an incorrect passphrase",function(){var t,n;beforeEach(function(){c.bp.isLocked=!0,r.get.and.returnValue(c),c.unlock.and.returnValue(s.reject(new Error("fail to unlock key")))}),beforeEach(function(r){e.unlock("valid-key-handle","incorrect passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.unlock).toHaveBeenCalledWith("incorrect passphrase")}),it("returns a Promise that rejects with a `fail to unlock key` {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("fail to unlock key")})}),describe("when the {OpgpLiveKey#unlock} method rejects with an {Error}",function(){var t,n;beforeEach(function(){c.bp.isLocked=!0,r.get.and.returnValue(c),c.unlock.and.returnValue(s.reject(new Error("boom")))}),beforeEach(function(r){e.unlock("valid-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.unlock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#unlock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("lock (keyRef: Eventual<KeyRef>, passphrase: Eventual<string>, opts?: Eventual<UnlockOpts>): Promise<OpgpProxyKey>",function(){describe("when given a valid handle string of an unlocked key and a passphrase string",function(){var t,n,i;beforeEach(function(){c.bp.isLocked=!1,t={key:{},bp:{isLocked:!0,keys:[{id:"key-id"}],user:{ids:[]}}},r.get.and.returnValue(c),c.lock.and.returnValue(s.resolve(t)),r.set.and.returnValue("locked-key-handle")}),beforeEach(function(t){e.lock(s.resolve("unlocked-key-handle"),"secret passphrase").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("unlocked-key-handle")}),it("invalidates the original {OpgpLiveKey} from the cache",function(){expect(r.del).toHaveBeenCalledWith("unlocked-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.lock).toHaveBeenCalledWith("secret passphrase")}),it("stores the unlocked key in the underlying cache",function(){expect(r.set).toHaveBeenCalledWith(t)}),it("returns a Promise that resolves to an {OpgpProxyKey} instance of the locked {OpgpLiveKey} instance",function(){expect(i).toEqual(jasmine.objectContaining({handle:"locked-key-handle"})),expect(i).toEqual(jasmine.objectContaining(t.bp)),expect(n).not.toBeDefined()})}),describe("when the referenced {OpgpLiveKey} instance is already locked",function(){var t,n;beforeEach(function(){c.bp.isLocked=!0,r.get.and.returnValue(c)}),beforeEach(function(r){e.lock("locked-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("locked-key-handle")}),it("does not invalidate the original {OpgpLiveKey} from the cache",function(){expect(r.del).not.toHaveBeenCalled()}),it("does notdelegate to the retrieved {OpgpLiveKey} instance",function(){expect(c.lock).not.toHaveBeenCalled()}),it("returns a Promise that rejects with a `key not unlocked` {Error} from the {OpgpLiveKey#lock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not unlocked")})}),describe("when given a stale or invalid handle",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.lock("stale-key-handle","secret passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when the {OpgpLiveKey#lock} method rejects with an {Error}",function(){var t,n;beforeEach(function(){r.get.and.returnValue(c),c.lock.and.returnValue(s.reject(new Error("boom")))}),beforeEach(function(r){e.lock("valid-key-handle","passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("invalidates the original {OpgpLiveKey} from the cache",function(){expect(r.del).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the retrieved {OpgpLiveKey} instance",function(){expect(c.lock).toHaveBeenCalledWith("passphrase")}),it("returns a Promise that rejects with the {Error} from the {OpgpLiveKey#lock} method",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("encrypt (keyRefs: Eventual<KeyRefMap>, plain: Eventual<string>, opts?: Eventual<EncryptOpts>): Promise<string>",function(){describe("when given a valid plain text string, and valid handles of valid public cipher and private authentication keys",function(){var t,n;beforeEach(function(){c.bp.isLocked=!1,r.get.and.returnValue(c),a.encrypt.and.returnValue({data:"cipher text"})}),beforeEach(function(r){e.encrypt(s.resolve({cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"}),"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(r.get.calls.allArgs()).toEqual([["valid-auth-key-handle"],["valid-cipher-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(a.encrypt).toHaveBeenCalledWith(jasmine.objectContaining({data:"plain text",publicKeys:[c.key],privateKeys:[c.key]}))}),it("returns a Promise that resolves to an armor string of the given text string encrypted with the referenced cipher {OpgpLiveKey} instances and signed with the referenced authentication {OpgpLiveKey} instances ",function(){expect(n).toBe("cipher text"),expect(t).not.toBeDefined()})}),describe("when given a valid plain text string and a stale handle string",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.encrypt({cipher:"stale-key-handle",auth:"stale-key-handle"},"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(a.encrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given a valid plain text string, and a valid handle string of a locked private key",function(){var t,n;beforeEach(function(){c.bp.isLocked=!0,r.get.and.returnValue(c)}),beforeEach(function(r){e.encrypt({cipher:"cipher-key-handle",auth:"locked-auth-key-handle"},"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("locked-auth-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(a.encrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `private key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("private key not unlocked")})}),describe("when the underlying openpgp primitive rejects with an {Error}",function(){var t,n;beforeEach(function(){c.bp.isLocked=!1,r.get.and.returnValue(c),a.encrypt.and.returnValue(s.reject(new Error("boom")))}),beforeEach(function(r){e.encrypt({cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"},"plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(r.get.calls.allArgs()).toEqual([["valid-auth-key-handle"],["valid-cipher-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(a.encrypt).toHaveBeenCalledWith(jasmine.objectContaining({data:"plain text",publicKeys:[c.key],privateKeys:[c.key]}))}),it("returns a Promise that rejects with the {Error} from the openpgp primitive",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")})})}),describe("decrypt (keyRefs: Eventual<KeyRefMap>, cipher: Eventual<string>, opts?: Eventual<DecryptOpts>): Promise<string>",function(){var t;beforeEach(function(){t={}}),describe("when given a valid cipher text string, and valid handles of valid public authentication and a private cipher key",function(){var n,i;beforeEach(function(){c.bp.isLocked=!1,r.get.and.returnValue(c),a.message.readArmored.and.returnValue(t),a.decrypt.and.returnValue({data:"plain text"})}),beforeEach(function(t){e.decrypt(s.resolve({cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"}),"cipher text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(r.get.calls.allArgs()).toEqual([["valid-cipher-key-handle"],["valid-auth-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(a.message.readArmored).toHaveBeenCalledWith("cipher text"),expect(a.decrypt).toHaveBeenCalledWith(jasmine.objectContaining({message:t,publicKeys:[c.key],privateKeys:c.key}))}),it("returns a Promise that resolves to an armor string of the given text string decrypted with the referenced cipher {OpgpLiveKey} instance and authenticated with the referenced authentication {OpgpLiveKey} instances ",function(){expect(i).toBe("plain text"),expect(n).not.toBeDefined()})}),describe("when given a valid plain text string and a stale handle string",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.decrypt({cipher:"stale-key-handle",auth:"stale-key-handle"},"cipher text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(a.message.readArmored).not.toHaveBeenCalled(),expect(a.decrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given a valid plain text string, and a valid handle string of a locked private key",function(){var t,n;beforeEach(function(){c.bp.isLocked=!0,r.get.and.returnValue(c)}),beforeEach(function(r){e.decrypt({cipher:"locked-cipher-key-handle",auth:"auth-key-handle"},"cipher text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("locked-cipher-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(a.message.readArmored).not.toHaveBeenCalled(),expect(a.decrypt).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `private key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("private key not unlocked")})}),describe("when the underlying openpgp primitive rejects with an {Error}",function(){var n,i;beforeEach(function(){c.bp.isLocked=!1,r.get.and.returnValue(c),a.message.readArmored.and.returnValue(t),a.decrypt.and.returnValue(s.reject(new Error("boom")))}),beforeEach(function(t){e.decrypt({cipher:"valid-cipher-key-handle",auth:"valid-auth-key-handle"},"cipher text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){expect(r.get.calls.allArgs()).toEqual([["valid-cipher-key-handle"],["valid-auth-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(a.message.readArmored).toHaveBeenCalledWith("cipher text"),expect(a.decrypt).toHaveBeenCalledWith(jasmine.objectContaining({message:t,publicKeys:[c.key],privateKeys:c.key}))}),it("returns a Promise that rejects with the {Error} from the openpgp primitive",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("boom")})})}),describe("sign (keyRefs: Eventual<KeyRef[]|KeyRef>, text: Eventual<string>, opts?: Eventual<SignOpts>): Promise<string>",function(){var t;beforeEach(function(){t=jasmine.createSpyObj("message",["sign","armor"])}),describe("when given a text string and a valid handle string that is not stale",function(){var n,i;beforeEach(function(){r.get.and.returnValue(c),a.message.fromText.and.returnValue(t),t.sign.and.returnValue(s.resolve(t)),t.armor.and.returnValue("signed-armor-text")}),beforeEach(function(t){e.sign(s.resolve("valid-key-handle"),"plain text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-key-handle")}),it("delegates to the openpgp primitive",function(){expect(a.message.fromText).toHaveBeenCalledWith("plain text"),expect(t.sign).toHaveBeenCalledWith([c.key]),expect(t.armor).toHaveBeenCalledWith()}),it("returns a Promise that resolves to an armor string of the given text string signed with the referenced {OpgpLiveKey} instance ",function(){expect(i).toBe("signed-armor-text"),expect(n).not.toBeDefined()})}),describe("when given a text string and a stale handle string",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.sign("stale-key-handle","plain text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(a.message.fromText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given non-compliant arguments",function(){var t,n;beforeEach(function(){r.get.and.returnValue(c)}),beforeEach(function(r){var i=p();s.any(i.map(function(t){return e.sign.apply(e,t)})).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){r.get.calls.allArgs().forEach(function(e){return expect(e).toEqual(["compliant handle"])})}),it("does not delegate to the openpgp primitive",function(){expect(a.message.fromText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` or an `invalid text: not a string` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(s.AggregateError)),t.forEach(function(e){expect(e).toEqual(jasmine.any(Error)),expect(e.message).toEqual(jasmine.stringMatching(/invalid key reference: not a string or stale|invalid text: not a string/))})})})}),describe("verify (keyRefs: Eventual<KeyRef[]|KeyRef>, armor: Eventual<string>, opts?: Eventual<VerifyOpts>): Promise<string>",function(){var t;beforeEach(function(){t=jasmine.createSpyObj("message",["verify","getText"])}),describe("when given a signed armor text string and the valid handle string of the corresponding authentication key",function(){var n,i;beforeEach(function(){r.get.and.returnValue(c),a.message.readArmored.and.returnValue(t),t.verify.and.returnValue(s.resolve([{keyid:"keyid",valid:!0}])),t.getText.and.returnValue("plain-text")}),beforeEach(function(t){e.verify(s.resolve("valid-auth-key-handle"),"signed armor text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("valid-auth-key-handle")}),it("delegates to the openpgp primitive",function(){expect(a.message.readArmored).toHaveBeenCalledWith("signed armor text"),expect(t.verify).toHaveBeenCalledWith([c.key]),expect(t.getText).toHaveBeenCalledWith()}),it("returns a Promise that resolves to the plain text string",function(){expect(i).toBe("plain-text"),expect(n).not.toBeDefined()})}),describe("when given a signed armor text string and a valid handle string of the wrong authentication key",function(){var n,i;beforeEach(function(){r.get.and.returnValue(c),a.message.readArmored.and.returnValue(t),t.verify.and.returnValue(s.resolve([{keyid:"verified-keyid",valid:!0},{keyid:"wrong-keyid",valid:!1},{keyid:"another-wrong-keyid",valid:!1}]))}),beforeEach(function(t){e.verify(["correct-key-handle","wrong-key-handle","another-wrong-key-handle"],"signed armor text").then(function(e){return i=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("retrieves the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get.calls.allArgs()).toEqual([["correct-key-handle"],["wrong-key-handle"],["another-wrong-key-handle"]])}),it("delegates to the openpgp primitive",function(){expect(a.message.readArmored).toHaveBeenCalledWith("signed armor text"),expect(t.verify).toHaveBeenCalledWith([c.key,c.key,c.key]),expect(t.getText).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an {Error} containing a message with a trailing list of the key IDs that fail authentication",function(){expect(i).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("authentication failed: wrong-keyid,another-wrong-keyid")})}),describe("when given a signed armor text string and a stale handle string",function(){var t,n;beforeEach(function(){r.get.and.returnValue(void 0)}),beforeEach(function(r){e.verify("stale-key-handle","signed armor text").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instance referenced by the given handle",function(){expect(r.get).toHaveBeenCalledWith("stale-key-handle")}),it("does not delegate to the openpgp primitive",function(){expect(a.message.readArmored).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("invalid key reference: not a string or stale")})}),describe("when given non-compliant arguments",function(){var t,n;beforeEach(function(){r.get.and.returnValue(c)}),beforeEach(function(r){var i=p();s.any(i.map(function(t){return e.verify.apply(e,t)})).then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("attempts to retrieve the {OpgpLiveKey} instances referenced by the given handles when compliant",function(){r.get.calls.allArgs().forEach(function(e){return expect(e).toEqual(["compliant handle"])})}),it("does not delegate to the openpgp primitive",function(){expect(a.message.readArmored).not.toHaveBeenCalled()}),it("returns a Promise that rejects with an `invalid key reference: not a string or stale` or an `invalid armor: not a string` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(s.AggregateError)),t.forEach(function(e){expect(e).toEqual(jasmine.any(Error)),expect(e.message).toEqual(jasmine.stringMatching(/invalid key reference: not a string or stale|invalid armor: not a string/))})})})})})},{4:4,undefined:void 0}],4:[function(e,t,n){"use strict";var r=this&&this.__assign||function(){return(r=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(n,"__esModule",{value:!0});var i=e(5),o=e(6),a=e(7),c=e("csrkey-cache"),u=e("bluebird"),s=e("resolve-call").default({Promise:u}),p={size:4096,unlocked:!1},l=function(){function t(e,t,n,r){this.cache=e,this.getLiveKey=t,this.getProxyKey=n,this.openpgp=r}return t.prototype.configure=function(e){var t=y(this.openpgp,e);return u.resolve(r({},t.config))},t.prototype.isValidKeyHandle=function(e){var t=this;return u.try(function(){return t._getCachedLiveKey(e)}).catch(function(){return!1}).then(Boolean)},t.prototype.generateKey=function(e,t){var n=this;return m(e)?function(e){return!e||(!e.passphrase||a.isString(e.passphrase))&&(!e.size||a.isNumber(e.size))&&(!e.unlocked||a.isBoolean(e.unlocked))}(t)?u.try(function(){return n.openpgp.key.generate(function(e,t){var n=r({user:[].concat(e)},p,t),i={userIds:n.user,numBits:n.size,unlocked:n.unlocked};return n.passphrase&&(i.passphrase=n.passphrase),i}(e,t))}).then(function(e){return n.getLiveKey(e)}).then(function(e){return n.cacheAndProxyKey(e)}):f("invalid key options"):f("invalid user")},t.prototype.getPublicKey=function(e){var t=this;return u.try(function(){return t._getCachedLiveKey(e)}).then(function(n){return n.bp.isPublic?t.getProxyKey(h(e),n.bp):n.toPublicKey().then(function(e){return t.cacheAndProxyKey(e)})})},t.prototype.getKeysFromArmor=function(e,t){var n=this;return a.isString(e)?u.try(function(){var t=n.openpgp.key.readArmored(e).keys.map(function(e){return n.getLiveKey(e).then(function(e){return n.cacheAndProxyKey(e)})});return u.all(t).then(function(e){return e.length>1?e:e[0]})}):f("invalid armor: not a string")},t.prototype.getArmorFromKey=function(e){var t=this;return u.try(function(){return t._getCachedLiveKey(e).armor()})},t.prototype.unlock=function(e,t,n){var r=this;return a.isString(t)?u.try(function(){return r._getCachedLiveKey(e).unlock(t)}).then(function(e){return r.cacheAndProxyKey(e)}):f("invalid passphrase: not a string")},t.prototype.lock=function(e,t,n){var r=this;return a.isString(t)?u.try(function(){var n=r._getCachedLiveKey(e);if(n.bp.isLocked)return f("key not unlocked");var i=h(e);return r.cache.del(i),n.lock(t)}).then(function(e){return r.cacheAndProxyKey(e)}):f("invalid passphrase: not a string")},t.prototype.encrypt=function(e,t,n){var r=this;return a.isString(t)?u.try(function(){return r.openpgp.encrypt({privateKeys:r.getCachedPrivateOpenpgpKeys(e.auth),publicKeys:r.getCachedOpenpgpKeys(e.cipher),data:t})}).get("data"):f("invalid plain text: not a string")},t.prototype.decrypt=function(e,t,n){var r=this;return a.isString(t)?u.try(function(){return r.openpgp.decrypt({privateKeys:r.getCachedPrivateOpenpgpKeys(e.cipher)[0],publicKeys:r.getCachedOpenpgpKeys(e.auth),message:r.openpgp.message.readArmored(t)})}).get("data"):f("invalid cipher: not a string")},t.prototype.sign=function(e,t,n){var r=this;return u.try(function(){var n=r.getCachedOpenpgpKeys(e);return a.isString(t)?r.openpgp.message.fromText(t).sign(n).then(function(e){return e.armor()}):f("invalid text: not a string")})},t.prototype.verify=function(e,t,n){var r=this;return u.try(function(){var n=r.getCachedOpenpgpKeys(e);if(!a.isString(t))return f("invalid armor: not a string");var i=r.openpgp.message.readArmored(t);return i.verify(n).then(function(e){var t=e.filter(function(e){return!e.valid}).map(function(e){return e.keyid}).join();return t?f("authentication failed: "+t):i.getText()})})},t.prototype._getCachedLiveKey=function(e){var t=h(e),n=t&&this.cache.get(t);if(!n)throw new Error("invalid key reference: not a string or stale");return n},t.prototype.getCachedLiveKeys=function(e){var t=this,n=[].concat(e);if(!n.length)throw new Error("no key references");return n.map(function(e){return t._getCachedLiveKey(e)})},t.prototype.getCachedOpenpgpKeys=function(e){return this.getCachedLiveKeys(e).map(function(e){return e.key})},t.prototype.getCachedPrivateOpenpgpKeys=function(e){var t=this.getCachedLiveKeys(e);if(t.some(function(e){return e.bp.isLocked}))throw new Error("private key not unlocked");return t.map(function(e){return e.key})},t.prototype.cacheAndProxyKey=function(e){var t=this.cache.set(e);if(!t)throw new Error("fail to cache key");return this.getProxyKey(t,e.bp)},t.getInstance=function(n){var u=r({},n),p=u.cache||c.default(),l=function(t){return function(e){return!!e&&["config","crypto","key","message"].every(function(t){return!!e[t]})&&[e.encrypt,e.decrypt,e.crypto.hash&&e.crypto.hash.sha256,e.key.readArmored,e.key.generate,e.message.fromText,e.message.readArmored].every(function(e){return a.isFunction(e)})}(t)?t:y(e("openpgp"),d,t)}(u.openpgp),f=new t(p,u.getLiveKey||i.default({openpgp:l}),u.getProxyKey||o.default,l);return t.PUBLIC_METHODS.reduce(function(e,t){return e[t]=s(f[t]).bind(f),e},{})},t.PUBLIC_METHODS=["configure","isValidKeyHandle","generateKey","getPublicKey","getKeysFromArmor","getArmorFromKey","unlock","lock","encrypt","decrypt","sign","verify"],t}();function f(e){return u.reject(new Error(e))}function h(e){var t=a.isString(e)?e:!!e&&e.handle;return a.isString(t)&&t}var d={aead_protect:!0,aead_protect_version:0};function y(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];var r=[e.config].concat(t.map(v));return Object.assign.apply(Object,r),e}var g={prefer_hash_algorithm:a.isNumber,encryption_cipher:a.isNumber,compression:a.isNumber,aead_protect:a.isBoolean,integrity_protect:a.isBoolean,ignore_mdc_error:a.isBoolean,rsa_blinding:a.isBoolean,use_native:a.isBoolean,zero_copy:a.isBoolean,debug:a.isBoolean,show_version:a.isBoolean,show_comment:a.isBoolean,versionstring:a.isString,commentstring:a.isString,keyserver:a.isString,node_store:a.isString};function v(e){return Object.keys(e||{}).reduce(function(t,n){var r=g[n];if(!r)return t;var i=e[n];return r(i)?(t[n]=i,t):t},{})}function m(e){return Array.isArray(e)?e.every(m):a.isString(e)||!!e&&a.isString(e.email)&&(!name||a.isString(e.name))}var k=l.getInstance;n.default=k},{5:5,6:6,7:7,openpgp:"openpgp",undefined:void 0}],3:[function(e,t,n){"use strict";var r=this&&this.__assign||function(){return(r=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(n,"__esModule",{value:!0});var i,o,a,c,u,s,p,l,f,h,d,y=e(5),g=e("base64-js");beforeEach(function(){o={crypto:{hash:jasmine.createSpyObj("hash",["sha256"])},key:jasmine.createSpyObj("key",["readArmored"]),message:jasmine.createSpyObj("message",["fromText","readArmored"])},c={bytes:"key-id"},a=jasmine.createSpyObj("key",["armor","toPublic","isPublic","getUserIds","getSigningKey","getEncryptionKey","verifyPrimaryKey","getExpirationTime","encrypt","decrypt"]),p=[0,1,2,3].map(function(e){return jasmine.createSpyObj("packet"+e,["getFingerprint","writeOld"])}),s=[0,1,2].map(function(e){return jasmine.createSpyObj("subkey"+e,["verify","getKeyId","getExpirationTime"])}),l=jasmine.createSpyObj("msg",["sign","verify"]),a.armor.and.returnValue("key-armor"),a.isPublic.and.returnValue(!1),a.getUserIds.and.returnValue(["user@test.io"]),a.getSigningKey.and.returnValue(p[0]),a.getEncryptionKey.and.returnValue(p[0]),a.verifyPrimaryKey.and.returnValue(Promise.resolve(6510)),a.getExpirationTime.and.returnValue(Promise.resolve(1/0)),(u=jasmine.createSpyObj("primaryKey",["isDecrypted","getFingerprint","writeOld"])).isDecrypted.and.returnValue(!1),u.getFingerprint.and.returnValue("0"),u.writeOld.and.returnValue(["old-primary-key-bytes"]),a.primaryKey=u,p.forEach(function(e,t){e.getFingerprint.and.returnValue(t.toString()),e.writeOld.and.returnValue(["old"+t])}),s.forEach(function(e,t){e.verify.and.returnValue(Promise.resolve(6511+t)),e.getKeyId.and.returnValue(r({},c)),e.getExpirationTime.and.returnValue(new Date(1984-t)),e.keyPacket=p[t+1]}),a.subKeys=s,d=function(e){var t=r({},e);return t.primaryKey=r({},e.primaryKey),t.subKeys=e.subKeys.map(function(e){return r({},e)}),t},o.crypto.hash.sha256.and.returnValue(g.toByteArray("c2hhMjU2")),o.key.readArmored.and.callFake(function(){return{keys:[d(a)]}}),o.message.readArmored.and.returnValue(l),o.message.fromText.and.returnValue(l),h={key:a,bp:jasmine.any(Object),armor:jasmine.any(Function),unlock:jasmine.any(Function),lock:jasmine.any(Function),sign:jasmine.any(Function),verify:jasmine.any(Function)},f={isLocked:!0,isPublic:!1,keys:[0,1,2,3].map(function(e){return{isAuth:!0,isCiph:!0,expires:e?1985-e:1/0,fingerprint:e.toString(),hash:"c2hhMjU2",status:6510+e}}),user:{ids:["user@test.io"]}}}),beforeEach(function(){i=y.default({openpgp:o})}),describe("default export: getLiveKeyFactory (config: {openpgp:any}): LiveKeyFactory",function(){it("returns a {LiveKey} factory when given an instance of openpgp",function(){expect(i).toEqual(jasmine.any(Function))})}),describe("LiveKeyFactory: getLiveKey (key: any, opts?: LiveKeyFactoryOpts): Promise<OpgpLiveKey>",function(){var e,t;beforeEach(function(n){i(a).then(function(t){return e=t}).catch(function(e){return t=e}).finally(function(){return setTimeout(n)})}),it("return a Promise that resolves to a {OpgpLiveKey} instance, that wraps the given openpgp key",function(){expect(e).toEqual(jasmine.objectContaining(h)),expect(t).toBeUndefined()})}),describe("OpgpLiveKey",function(){var e;beforeEach(function(t){i(a).then(function(t){return e=t}).finally(function(){return setTimeout(t)})}),describe("bp: OpgpKeyBlueprint",function(){var t;beforeEach(function(){t=e.bp}),it("is a blueprint of the openpgp wrapped in the {OpgpLiveKey} instance:\n{\n  isLocked: boolean,\n  isPublic: boolean,\n  keys: OpgpKeyId[],\n  user: { ids: string[] }\n}\nwhere each {OpgpKeyId} element in `keys` is a blueprint of the corresponding key component:\n{\n  isAuth: boolean,\n  isCiph: boolean,\n  expires: number,\n  fingerprint: string,\n  hash: string,\n  status: number\n}",function(){expect(t).toEqual(f)})}),describe("armor (): Promise<string>",function(){describe("when the openpgp primitive succeeds",function(){var t,n;beforeEach(function(r){e.armor().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that resolves to an armored string representation of the wrapped openpgp key when the openpgp primitive succeeds",function(){expect(a.armor).toHaveBeenCalled(),expect(n).toBe("key-armor"),expect(t).not.toBeDefined()})}),describe("when the openpgp primitive fails",function(){var t,n;beforeEach(function(r){a.armor.and.throwError("boom"),e.armor().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with the error from the openpgp primitive when it fails",function(){expect(a.armor).toHaveBeenCalled(),expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("boom")})})}),describe("toPublicKey (): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){(t=d(a)).isPublic=jasmine.createSpy("armor").and.returnValue(!0)}),describe("when this {LiveKey} wraps a private openpgp key",function(){var n,r;beforeEach(function(i){h.key=t,a.toPublic.and.returnValue(t),e.toPublicKey().then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(i)})}),it("delegates to the underlying openpgp primitive",function(){expect(a.toPublic).toHaveBeenCalledWith()}),it("returns a Promise that resolves to a {OpgpLiveKey} instance that wraps the public openpgp key of the wrapped openpgp key of this {LiveKey}",function(){expect(r).toEqual(jasmine.objectContaining(h)),expect(n).not.toBeDefined()})}),describe("when this {LiveKey} wraps a public openpgp key",function(){var e,n,r;beforeEach(function(e){i(t).then(function(e){return r=e}).finally(function(){return setTimeout(e)})}),beforeEach(function(t){r.toPublicKey().then(function(e){return n=e}).catch(function(t){return e=t}).finally(function(){return setTimeout(t)})}),it("does not delegate to the underlying openpgp primitive",function(){expect(a.toPublic).not.toHaveBeenCalled()}),it("returns this {OpgpLiveKey} instance ",function(){expect(n).toEqual(r),expect(e).not.toBeDefined()})}),describe("when the openpgp primitive fails",function(){var t,n;beforeEach(function(r){a.toPublic.and.throwError("boom"),e.toPublicKey().then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with the error from the openpgp primitive",function(){expect(a.toPublic).toHaveBeenCalled(),expect(n).not.toBeDefined(),expect(t).toBeDefined(),expect(t.message).toBe("boom")})})}),describe("unlock (passphrase: string, opts?: LiveKeyUnlockOpts): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){(t=d(a)).primaryKey.isDecrypted=jasmine.createSpy("isDecrypted").and.returnValue(!0)}),describe("when given the correct passphrase",function(){var n,r;beforeEach(function(i){o.key.readArmored.and.callFake(function(){var e=d(t);return e.decrypt=jasmine.createSpy("decrypt").and.returnValue(Promise.resolve(!0)),{keys:[e]}}),e.unlock("correct passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(i)})}),it("returns a Promise that resolves to a new, unlocked {OpgpLiveKey} instance",function(){expect(n).not.toBeDefined(),expect(r).not.toBe(e),expect(r.bp.isLocked).toBe(!1)}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(a),expect(e.key.primaryKey.isDecrypted()).toBe(!1),expect(e.bp.isLocked).toBe(!0),expect(e.key.decrypt).not.toHaveBeenCalled()})}),describe("when given an incorrect passphrase",function(){var t,n;beforeEach(function(r){a.decrypt.and.returnValue(Promise.resolve(!1)),e.unlock("incorrect passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with a `fail to unlock key` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("fail to unlock key")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(a),expect(e.key.primaryKey.isDecrypted()).toBe(!1),expect(e.bp.isLocked).toBe(!0)})}),describe("when its {OpgpLiveKey} is already unlocked",function(){var n,r;beforeEach(function(n){i(t).then(function(t){return e=t}).finally(function(){return setTimeout(n)})}),beforeEach(function(t){e.unlock("passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("returns a Promise that rejects with a `key not locked` {Error}",function(){expect(r).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("key not locked")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(t),expect(e.key.primaryKey.isDecrypted()).toBe(!0),expect(e.bp.isLocked).toBe(!1)})}),describe("when the openpgp primitive throws an exception",function(){var t,n;beforeEach(function(r){a.decrypt.and.returnValue(Promise.reject(new Error("boom"))),e.unlock("passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with the corresponding error",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("boom")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(a),expect(e.key.primaryKey.isDecrypted()).toBe(!1),expect(e.bp.isLocked).toBe(!0)})})}),describe("lock (passphrase: string, opts?: LiveKeyUnlockOpts): Promise<OpgpLiveKey>",function(){var t;beforeEach(function(){(t=d(a)).primaryKey.isDecrypted=jasmine.createSpy("isDecrypted").and.returnValue(!0)}),describe("when given a passphrase",function(){var n,r;beforeEach(function(n){t.encrypt=jasmine.createSpy("encrypt").and.returnValue(Promise.resolve(d(a))),i(t).then(function(t){return e=t}).finally(function(){return setTimeout(n)})}),beforeEach(function(t){e.lock("passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("returns a Promise that resolves to a new, locked {OpgpLiveKey} instance",function(){expect(n).not.toBeDefined(),expect(r).not.toBe(e),expect(r.bp.isLocked).toBe(!0)}),it("invalidates its {OpgpLiveKey} instance",function(){expect(e.key).not.toBeDefined()})}),describe("when its {OpgpLiveKey} is already locked",function(){var t,n;beforeEach(function(r){e.lock("passphrase").then(function(e){return n=e}).catch(function(e){return t=e}).finally(function(){return setTimeout(r)})}),it("returns a Promise that rejects with a `key not unlocked` {Error}",function(){expect(n).not.toBeDefined(),expect(t).toEqual(jasmine.any(Error)),expect(t.message).toBe("key not unlocked")}),it("does not change the state of its {OpgpLiveKey} instance",function(){expect(e.key).toBe(a),expect(e.key.primaryKey.isDecrypted()).toBe(!1),expect(e.bp.isLocked).toBe(!0)})}),describe("when the openpgp primitive throws an exception",function(){var n,r;beforeEach(function(n){a.encrypt.and.returnValue(Promise.reject(new Error("boom"))),i(t).then(function(t){return e=t}).finally(function(){return setTimeout(n)})}),beforeEach(function(t){e.lock("incorrect passphrase").then(function(e){return r=e}).catch(function(e){return n=e}).finally(function(){return setTimeout(t)})}),it("returns a Promise that rejects with the corresponding error",function(){expect(r).not.toBeDefined(),expect(n).toEqual(jasmine.any(Error)),expect(n.message).toBe("boom")}),it("invalidates its {OpgpLiveKey} instance",function(){expect(e.key).not.toBeDefined()})})})})},{5:5,undefined:void 0}],5:[function(e,t,n){(function(t){"use strict";var r=this&&this.__assign||function(){return(r=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(n,"__esModule",{value:!0});var i=e("base64-js"),o=e("bluebird"),a=function(){function e(e,t,n){this.utils=e,this.key=t,this.bp=n}return e.prototype.armor=function(){var e=this;return o.try(function(){return e.key.armor()})},e.prototype.toPublicKey=function(){var t=this;return this.bp.isPublic?o.resolve(this):o.try(function(){return t.key.toPublic()}).then(function(n){return t.utils.getKeyBlueprint(n).then(function(r){return new e(t.utils,n,r)})})},e.prototype.unlock=function(t,n){var r=this;return this.bp.isLocked?o.try(function(){var n=r.utils.cloneKey(r.key);return n.decrypt(t).then(function(t){return t?e.getInstance(r.utils,n):o.reject(new Error("fail to unlock key"))})}):o.reject(new Error("key not locked"))},e.prototype.lock=function(t,n){var r=this;return this.bp.isLocked?o.reject(new Error("key not unlocked")):o.try(function(){return r.key.encrypt(t).then(function(t){return e.getInstance(r.utils,t)})}).finally(function(){return delete r.key})},e.prototype.sign=function(e,n){var r=this;return"production"!==t.env.NODE_ENV&&console.log("WARNING: opgp-service/live-key#sign method is not tested."),o.try(function(){return r.utils.openpgp.message.fromText(e).sign([r.key]).then(function(e){return e.armor()})})},e.prototype.verify=function(e,n){var r=this;return"production"!==t.env.NODE_ENV&&console.log("WARNING: opgp-service/live-key#verify method is not tested."),o.try(function(){var t=r.utils.openpgp.message.readArmored(e);return t.verify([r.key]).then(function(e){return e.length&&e[0].valid?t.getText():o.reject(new Error("authentication failed"))})})},e.getInstance=function(t,n,r){return t.getKeyBlueprint(n).then(function(r){return new e(t,n,r)})},e.getFactory=function(t){var n=new c(t.openpgp);return e.getInstance.bind(e,n)},e}(),c=function(){function e(e){this.openpgp=e}return e.prototype.getKeyBlueprint=function(e){var t=this,n=this._getPrimaryOpgpKeyId(e),r=o.all(e.subKeys.map(function(n){return t._getSubkeyOpgpKeyId(e,n)}));return o.all([n,r]).then(function(t){var n=t[0],r=t[1];return{isLocked:function(e){return!e.primaryKey.isDecrypted()}(e),isPublic:e.isPublic(),keys:[n].concat(r),user:{ids:e.getUserIds()}}})},e.prototype.getHashes=function(e){return{hash:this.getFingerprintHash(e),fingerprint:e.getFingerprint()}},e.prototype.getPrimaryKeyType=function(e){var t=this.cloneKey(e);return t.subKeys=[],{isAuth:!!t.getSigningKey(),isCiph:!!t.getEncryptionKey()}},e.prototype.getFingerprintHash=function(e,t){var n=e.writeOld(),r=this.openpgp.crypto.hash[t&&t.hash||"sha256"](n);return i.fromByteArray(r)},e.prototype.cloneKey=function(e){return this.openpgp.key.readArmored(e.armor()).keys[0]},e.prototype._getPrimaryOpgpKeyId=function(e){var t=this,n=e.getExpirationTime().then(function(e){return e.valueOf()}),i=e.verifyPrimaryKey();return o.all([n,i]).then(function(n){var i=n[0],o=n[1];return r({},t.getHashes(e.primaryKey),t.getPrimaryKeyType(e),{status:o,expires:i.valueOf()})})},e.prototype._getSubkeyOpgpKeyId=function(e,t){var n=this;return t.verify(e.primaryKey).then(function(i){return r({},n.getHashes(t.keyPacket),{isCiph:!!e.getEncryptionKey(t.getKeyId()),isAuth:!!e.getSigningKey(t.getKeyId()),status:i,expires:t.getExpirationTime().valueOf()})})},e}();var u=a.getFactory;n.default=u}).call(this,e(1))},{1:1,undefined:void 0}],openpgp:[function(e,t,n){t.exports=openpgp},{}],6:[function(e,t,n){"use strict";var r=this&&this.__assign||function(){return(r=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(n,"__esModule",{value:!0});n.default=function(e,t){var n=r({handle:e},t);return n.keys=t.keys.map(function(e){return r({},e)}),n.user={ids:t.user.ids.slice()},n}},{}],7:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.isString=function(e){return"string"==typeof(e&&e.valueOf())},n.isNumber=function(e){return"number"==typeof(e&&e.valueOf())},n.isBoolean=function(e){return"boolean"==typeof(e&&e.valueOf())},n.isFunction=function(e){return"function"==typeof e}},{}]},{},[2,3]);